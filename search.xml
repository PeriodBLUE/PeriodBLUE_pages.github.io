<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/07/18/%E5%AF%BC%E8%AF%BB_1%20%5BModel%20Mixing_4Model%20Recombination%5D%20FedMR%EF%BC%9AFederated%20Learning%20via%20Model%20Recombination%202305.10730v1/"/>
      <url>/2024/07/18/%E5%AF%BC%E8%AF%BB_1%20%5BModel%20Mixing_4Model%20Recombination%5D%20FedMR%EF%BC%9AFederated%20Learning%20via%20Model%20Recombination%202305.10730v1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/18/FedMR%EF%BC%9AFederated%20Learning%20via%20Model%20Recombination/"/>
      <url>/2024/07/18/FedMR%EF%BC%9AFederated%20Learning%20via%20Model%20Recombination/</url>
      
        <content type="html"><![CDATA[<h1 id="导读-1-Model-Mixing-4Model-Recombination-FedMR：Federated-Learning-via-Model-Recombination-2305-10730v1-导读"><a href="#导读-1-Model-Mixing-4Model-Recombination-FedMR：Federated-Learning-via-Model-Recombination-2305-10730v1-导读" class="headerlink" title="[[导读_1 [Model Mixing_4Model Recombination] FedMR：Federated Learning via Model Recombination 2305.10730v1| 导读]]"></a>[[导读_1 [Model Mixing_4Model Recombination] FedMR：Federated Learning via Model Recombination 2305.10730v1| 导读]]</h1><h1 id="FedMR"><a href="#FedMR" class="headerlink" title="FedMR"></a>FedMR</h1><h2 id="Purpose-解决基于联邦平均法在不均匀数据的客户端表现不好的情况。"><a href="#Purpose-解决基于联邦平均法在不均匀数据的客户端表现不好的情况。" class="headerlink" title="Purpose:解决基于联邦平均法在不均匀数据的客户端表现不好的情况。"></a>Purpose:解决基于联邦平均法在不均匀数据的客户端表现不好的情况。</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>![[Pasted image 20240718004018.png]]</p><ul><li>（a）<ul><li>Step 1 Model Dispatching<br>云端派发k个模型给k个用户（注意的是会派发K个<strong>不同的模型</strong> 如图很清晰）（如果是联邦平均学习的话 就是派发K个相同模型）</li><li>Step 2 Model Upload<br>结合本地数据和派发获得的模型，在本地训练获得新模型，再上传对应参数到云端。 ^f7088f</li><li>Step 3 Model Recombination<br>基于上传得到的模型，对同一顺序下的不同层进行<strong>随机组合</strong>（这里居然是随机QAQ），获得最后结果 ^ab8197</li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>![[Pasted image 20240718005205.png]]<br>这个还蛮简单的，就是上图的一个算法具象化，表达都一样。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>本文还提到了一种优化方法<em>Two-Stage Training Scheme for FedMR</em>“两阶段训练策略”，可以加快收敛速度。<br>-&gt;为什么提出这个方法呢？<br>    因为发现FedMR再最开始比传统的FL慢<br>        原因：模型重组阶段[[#^ab8197 |Step3]],由于模型之间的匹配度比较低，所以在再次训练的时候就需要花费更多的本地训练时间。(注意这里是[[#^f7088f|step 2]]花费时间！)</p><h3 id="方法-减少了-f7088f-step2-的时间"><a href="#方法-减少了-f7088f-step2-的时间" class="headerlink" title="方法-&gt;减少了[[#^f7088f|step2]]的时间"></a>方法-&gt;减少了[[#^f7088f|step2]]的时间</h3><ul><li>aggregation-based pre-training stage<br>这个阶段就简单地用<em>FedAvg-based aggregation</em>,快速获得一个预训练的模型。</li><li>model recombination stage<br>将本地训练的模型组合起来（同[[#^ab8197|step 3]]）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/10/303-07-10/"/>
      <url>/2024/07/10/303-07-10/</url>
      
        <content type="html"><![CDATA[<h1 id="数独"><a href="#数独" class="headerlink" title="数独"></a><strong>数独</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240710153752134.png" alt="image-20240710153752134"></p><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240710153726153.png" alt="image-20240710153726153"></p><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240710153739515.png" alt="image-20240710153739515"></p><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 2 6 * * * * * *</span><br><span class="line">* * * 5 * 2 * * 4</span><br><span class="line">* * * 1 * * * * 7</span><br><span class="line">* 3 * * 2 * 1 8 *</span><br><span class="line">* * * 3 * 9 * * *</span><br><span class="line">* 5 4 * 1 * * 7 *</span><br><span class="line">5 * * * * 1 * * *</span><br><span class="line">6 * * 9 * 7 * * *</span><br><span class="line">* * * * * * 7 5 *</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 2 6 7 3 4 5 9 8</span><br><span class="line">3 7 8 5 9 2 6 1 4</span><br><span class="line">4 9 5 1 6 8 2 3 7</span><br><span class="line">7 3 9 4 2 5 1 8 6</span><br><span class="line">8 6 1 3 7 9 4 2 5</span><br><span class="line">2 5 4 8 1 6 3 7 9</span><br><span class="line">5 4 7 2 8 1 9 6 3</span><br><span class="line">6 1 3 9 5 7 8 4 2</span><br><span class="line">9 8 2 6 4 3 7 5 1</span><br></pre></td></tr></table></figure><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量N表示数独的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔变量ok用于标记是否找到解决方案</span></span><br><span class="line"><span class="type">int</span> ok;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组map存储数独的当前状态，-1表示空格</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组row、col和box分别记录每行、每列和每个3×3宫格中数字出现的情况</span></span><br><span class="line"><span class="type">int</span> row[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> col[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> box[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs函数使用深度优先搜索算法来填充数独</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经找到了一个解决方案，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果遍历到了最后一个单元格，则说明找到了一个解决方案</span></span><br><span class="line">    <span class="keyword">if</span> (x == N*N) &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前正在处理的行和列</span></span><br><span class="line">    <span class="type">int</span> i = x/N, j = x%N;</span><br><span class="line">    <span class="comment">// 如果当前位置已经有值了，则跳过这个位置继续处理下一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] != <span class="number">-1</span>)</span><br><span class="line">        dfs(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 遍历可能填入的位置的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++)</span><br><span class="line">            <span class="comment">// 检查该数字在当前行、列和3×3宫格中是否已存在</span></span><br><span class="line">            <span class="keyword">if</span> (!row[i][num] &amp;&amp; !col[j][num] &amp;&amp; !box[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>][num]) &#123;</span><br><span class="line">                <span class="comment">// 将当前数字填入到当前位置，并更新相关统计信息</span></span><br><span class="line">                <span class="built_in">map</span>[i][j] = num;</span><br><span class="line">                row[i][num] = <span class="number">1</span>;</span><br><span class="line">                col[j][num] = <span class="number">1</span>;</span><br><span class="line">                box[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 继续递归调用dfs函数尝试填充下一个位置</span></span><br><span class="line">                dfs(x+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果找到了解决方案，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (ok) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 回溯：将之前填入的数字删除并恢复相关统计信息</span></span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">-1</span>;</span><br><span class="line">                row[i][num] = <span class="number">0</span>;</span><br><span class="line">                col[j][num] = <span class="number">0</span>;</span><br><span class="line">                box[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">// 初始化数组map、col、row和box</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                row[i][c-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                col[j][c-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                box[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>][c-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 调用dfs函数开始求解数独</span></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出求解后的数独结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="鸣人和佐助"><a href="#鸣人和佐助" class="headerlink" title="鸣人和佐助"></a>鸣人和佐助</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240710153347334.png" alt="image-20240710153347334" style="zoom:90%;" /><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无穷大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入的参数：地图大小、时间限制、鸣人的查克拉数量</span></span><br><span class="line"><span class="type">int</span> M, N, T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储地图信息的二维数组</span></span><br><span class="line"><span class="type">char</span> <span class="built_in">map</span>[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录每个位置相应查克拉数量的最短步数</span></span><br><span class="line"><span class="type">int</span> step[<span class="number">200</span>][<span class="number">200</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标位置的坐标</span></span><br><span class="line"><span class="type">int</span> e_x, e_y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个方向的移动向量</span></span><br><span class="line"><span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化最小值为无穷大</span></span><br><span class="line"><span class="type">int</span> minval = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> now_T, <span class="type">int</span> now_step)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前查克拉小于0或者步数超出可行解，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (now_T &lt; <span class="number">0</span> || minval &lt;= now_step)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否到达终点</span></span><br><span class="line">    <span class="keyword">if</span> (i == e_x &amp;&amp; j == e_y) &#123;</span><br><span class="line">        minval = now_step;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可能的时间步，判断当前位置是否已经被访问过且花费的时间更少</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = now_T; t &lt;= T; t++)</span><br><span class="line">        <span class="keyword">if</span> (step[i][j][t] != <span class="number">-1</span> &amp;&amp; step[i][j][t] &lt;= now_step)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前位置在当前时间步的状态</span></span><br><span class="line">    step[i][j][now_T] = now_step;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历四个方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">4</span>; t++) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个位置的坐标</span></span><br><span class="line">        <span class="type">int</span> next_i = i + direction[t][<span class="number">0</span>], next_j = j + direction[t][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 越界检查</span></span><br><span class="line">        <span class="keyword">if</span> (next_i &lt; <span class="number">0</span> || next_i &gt;= M || next_j &lt; <span class="number">0</span> || next_j &gt;= N)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果下一个位置是通路，则继续执行深度优先搜索</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[next_i][next_j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            dfs(next_i, next_j, now_T, now_step+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 否则消耗一个单位的查克拉，并继续执行深度优先搜索</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dfs(next_i, next_j, now_T<span class="number">-1</span>, now_step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 输入地图大小、时间限制和鸣人的查克拉数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;M, &amp;N, &amp;T);</span><br><span class="line">    <span class="comment">// 初始化时间步数组</span></span><br><span class="line">    <span class="built_in">memset</span>(step, <span class="number">-1</span>, <span class="keyword">sizeof</span>(step));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入起始点和目标点的位置</span></span><br><span class="line">    <span class="type">int</span> s_x, s_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="comment">// 忽略每行前面的空格</span></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="comment">// 读取地图上的字符</span></span><br><span class="line">            <span class="built_in">map</span>[i][j] = getchar();</span><br><span class="line">            <span class="comment">// 将起点标记为通路</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                s_x = i;</span><br><span class="line">                s_y = j;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 将终点标记为通路</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                e_x = i;</span><br><span class="line">                e_y = j;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行深度优先搜索</span></span><br><span class="line">    dfs(s_x, s_y, T, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (minval==INF) ? <span class="number">-1</span> : minval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="蒜头君回家"><a href="#蒜头君回家" class="headerlink" title="蒜头君回家"></a>蒜头君回家</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240710153521799.png" alt="image-20240710153521799"></p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 输入地图的行数和列数</span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维字符数组来存储地图信息</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">map</span>[n][m];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个一维整型数组分别用来存储队列中的位置和是否有钥匙</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[n*m*<span class="number">2</span>], key[n*m*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列的尾部和头部指针</span></span><br><span class="line">    <span class="type">int</span> tail=<span class="number">0</span>, head=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每个位置相应钥匙状态的最短步数</span></span><br><span class="line">    <span class="type">int</span> step[n][m][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录终点的位置</span></span><br><span class="line">    <span class="type">int</span> e_x, e_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step数组初始化为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(step, <span class="number">-1</span>, <span class="keyword">sizeof</span>(step));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输入的地图信息，并处理特殊字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        getchar(); <span class="comment">// 跳过换行符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = getchar();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理起点和终点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                e_x = i;    e_y = j;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 将终点替换为可通行点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">queue</span>[tail] = i*m + j; <span class="comment">// 将起点加入队列</span></span><br><span class="line">                key[tail++] = <span class="number">0</span>; <span class="comment">// 设置钥匙数量为0</span></span><br><span class="line">                step[i][j][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 设置起点的步数为0</span></span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 将起点替换为可通行点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个二维整型数组表示四个方向</span></span><br><span class="line">    <span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当队列不为空时执行循环</span></span><br><span class="line">    <span class="keyword">while</span> (tail &gt; head) &#123;</span><br><span class="line">        <span class="comment">// 取出队列头部元素</span></span><br><span class="line">        <span class="type">int</span> now_pos = <span class="built_in">queue</span>[head];</span><br><span class="line">        <span class="type">int</span> now_key = key[head++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前位置的坐标</span></span><br><span class="line">        <span class="type">int</span> now_i = now_pos/m, now_j = now_pos%m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达了终点并且有钥匙，则结束搜索并输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (now_i==e_x &amp;&amp; now_j==e_y &amp;&amp; now_key==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前步数</span></span><br><span class="line">        <span class="type">int</span> now_step = step[now_i][now_j][now_key];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于四个可能的方向进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算下一个位置的坐标</span></span><br><span class="line">            <span class="type">int</span> next_i = now_i + direction[i][<span class="number">0</span>], next_j = now_j + direction[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否越界或遇到障碍物</span></span><br><span class="line">            <span class="keyword">if</span> (next_i&lt;<span class="number">0</span> || next_i&gt;=n || next_j&lt;<span class="number">0</span> || next_j&gt;=m || <span class="built_in">map</span>[next_i][next_j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新钥匙状态</span></span><br><span class="line">            <span class="type">int</span> next_key = now_key;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[next_i][next_j] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">                next_key = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前位置及状态是否已被访问</span></span><br><span class="line">            <span class="keyword">if</span> (step[next_i][next_j][next_key] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新的位置和钥匙数量加入队列</span></span><br><span class="line">            <span class="built_in">queue</span>[tail] = next_i*m + next_j;</span><br><span class="line">            key[tail++] = next_key;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新新路径的步数</span></span><br><span class="line">            step[next_i][next_j][next_key] = now_step+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出从起点到终点的最短步数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, step[e_x][e_y][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回0表示程序正常结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2024/04/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理复习提纲"><a href="#编译原理复习提纲" class="headerlink" title="编译原理复习提纲"></a>编译原理复习提纲</h1><p>平时成绩和期末考试三七开</p><p><img src="https://s2.loli.net/2022/05/26/UjQWISZtcLuefpH.png" alt="image-20220526204459570"></p><p>😻🙈微雕技术~~</p><p>第10章 符号表 和第12章 目标代码生成不考</p><p>第9章和第11章 各10分</p><p>前端是考察的重点</p><p><img src="https://s2.loli.net/2022/05/26/45eA8r9uvUFbCDc.png" alt="image-20220526204148132"></p><p>这次好像没有考察自然语言？</p><p>文法判定：分析表中不含多重定义的表项</p><h2 id="第1章-引论-（不会直接考察，贯穿始终）"><a href="#第1章-引论-（不会直接考察，贯穿始终）" class="headerlink" title="第1章 引论 （不会直接考察，贯穿始终）"></a>第1章 引论 （不会直接考察，贯穿始终）</h2><p><img src="https://s2.loli.net/2022/05/26/tK9uabnqhfP4ED2.png" alt="image-20220526194114619"></p><p>期末考试不考编译程序的构造这一部分</p><h2 id="第二章-形式语言概论（重点）"><a href="#第二章-形式语言概论（重点）" class="headerlink" title="第二章 形式语言概论（重点）"></a>第二章 形式语言概论（重点）</h2><p>csg和psg不考</p><p><img src="https://s2.loli.net/2022/05/26/JBEgFNuvUArpmd7.png" alt="image-20220526194329141"></p><p><img src="https://s2.loli.net/2022/05/26/lz94BGFV5W6csIn.png" alt="image-20220526194546061"></p><h2 id="第三章-有穷自动机（重点）"><a href="#第三章-有穷自动机（重点）" class="headerlink" title="第三章 有穷自动机（重点）"></a>第三章 有穷自动机（重点）</h2><p><img src="https://s2.loli.net/2022/05/26/PEJv1yFKwZhV7pW.png" alt="image-20220526194826366"></p><h2 id="第四章-词法分析（不考）"><a href="#第四章-词法分析（不考）" class="headerlink" title="第四章 词法分析（不考）"></a>第四章 词法分析（不考）</h2><p><img src="https://s2.loli.net/2022/05/26/EtMYhcI5LnUpvJO.png" alt="image-20220526195215404"></p><h2 id="第五章-自上而下的语法分析（重点）"><a href="#第五章-自上而下的语法分析（重点）" class="headerlink" title="第五章 自上而下的语法分析（重点）"></a>第五章 自上而下的语法分析（重点）</h2><p><img src="https://s2.loli.net/2022/05/26/BhAwtc2X8fbMdHF.png" alt="image-20220526195501059"></p><h2 id="第六章-自下而上的语法分析（优先分析方法不考）"><a href="#第六章-自下而上的语法分析（优先分析方法不考）" class="headerlink" title="第六章 自下而上的语法分析（优先分析方法不考）"></a>第六章 自下而上的语法分析（优先分析方法不考）</h2><p><img src="https://s2.loli.net/2022/05/26/hzAEPdBNHpk9ZIc.png" alt="image-20220526195640595"></p><h2 id="第七章-LR-k-分析方法（重点）"><a href="#第七章-LR-k-分析方法（重点）" class="headerlink" title="第七章 LR(k)分析方法（重点）"></a>第七章 LR(k)分析方法（重点）</h2><p><img src="https://s2.loli.net/2022/05/26/Zldcjh2ovNn3k9R.png" alt="image-20220526195712498"></p><p>前两种方法要会造表，LR(1)给表要会查表（跟前两种算法的查表没啥区别）</p><p>期末考试可能会要求把两个栈分开来，按照试卷要求的格式来</p><p><img src="https://s2.loli.net/2022/05/26/ZSkK5wQj7AdF2sG.png" alt="image-20220526200226548"></p><p><img src="https://s2.loli.net/2022/05/26/zCbs3SUpfAB6uZN.png" alt="image-20220526200340370"></p><p>不考LALR（1）</p><p><img src="https://s2.loli.net/2022/05/26/kUZ5duG6hcvTVPi.png" alt="image-20220526200453167"></p><h2 id="第8章-语法制导翻译法（二十分😥😱）"><a href="#第8章-语法制导翻译法（二十分😥😱）" class="headerlink" title="第8章 语法制导翻译法（二十分😥😱）"></a>第8章 语法制导翻译法（二十分😥😱）</h2><p><img src="https://s2.loli.net/2022/05/26/92KdQsm6wqiMgjy.png" alt="image-20220526200602899"></p><p>三元式和逆波兰不考</p><p><img src="https://s2.loli.net/2022/05/26/YfhVIn2zXABviRD.png" alt="image-20220526201233121"></p><p><img src="https://s2.loli.net/2022/05/26/VFHv7LlK1BCrfQj.png" alt="image-20220526201624715"></p><p><img src="https://s2.loli.net/2022/05/26/yOSa4F7ZHPj68mL.png" alt="image-20220526201920869"></p><p><img src="https://s2.loli.net/2022/05/26/aIrTkzqnmxLb2Yy.png" alt="image-20220526202421264"></p><p>NAND 与非 ；NOR 或非</p><p><img src="https://s2.loli.net/2022/05/26/I4OtQBviMFjGLz1.png" alt="image-20220526202444276"></p><p><img src="https://s2.loli.net/2022/05/26/MSeoUW4YCnjufNH.png" alt="image-20220526202750632"></p><h2 id="第9章-存储组织与管理"><a href="#第9章-存储组织与管理" class="headerlink" title="第9章 存储组织与管理"></a>第9章 存储组织与管理</h2><p>了解有哪些存储分配方案，数据区(活动记录)如何分配，包含哪些内容等。不会涉及与具体语言相关的考题，不用担心不了解某某语言，了解分配机制即可。如果本章课后习题弄懂了就没问题了。</p><p>静态链是指向其（静态）直接外层的活动记录首地址，为的是实现非局部量的访问；<br>动态链是指向其调用者的活动记录首地址，为的是调用结束返回调用者活动记录。<br>二者一个是程序静态结构决定的；一个是调用过程中动态决定的。作用也各不相同。<br>只不过有些时候做的题，恰好调用者是它的直接外层，二者刚好一样而已。但其实机制和作用完全不同。<br>这部分内容有点容易搞混，大家不能光看题，要看书。<br>可以参看群内《陈火旺》教材的9.2和9.5节，写得很具体。</p><p><img src="https://s2.loli.net/2022/05/26/firVbkoI4EUMX5c.png" alt="image-20220526203354118"></p><h2 id="第10章-符号表（不考）"><a href="#第10章-符号表（不考）" class="headerlink" title="第10章 符号表（不考）"></a>第10章 符号表（不考）</h2><h2 id="第11章-优化（考的比较简单）"><a href="#第11章-优化（考的比较简单）" class="headerlink" title="第11章 优化（考的比较简单）"></a>第11章 优化（考的比较简单）</h2><p><img src="https://s2.loli.net/2022/05/26/w14A8CqhVQl3yPd.png" alt="image-20220526204024107"></p><p>重点考察利用无环有向图的基本块优化</p><h2 id="第12-章-代码生成（不考）"><a href="#第12-章-代码生成（不考）" class="headerlink" title="第12 章 代码生成（不考）"></a>第12 章 代码生成（不考）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/16/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%A4%A7%E9%A2%98/"/>
      <url>/2024/04/16/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%A4%A7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>&#x2F;&#x2F;网安是真的比计院考的难，计院一般都只考了基本题型的①和②</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="①性能评价指标"><a href="#①性能评价指标" class="headerlink" title="①性能评价指标"></a>①性能评价指标</h4><table><thead><tr><th>指标</th><th>含义</th></tr></thead><tbody><tr><td>响应时间</td><td>从提交请求到被响应的时间间隔</td></tr><tr><td>周转时间</td><td>从一个作业提交给系统开始到作业完成时的时间间隔</td></tr><tr><td>运行时间</td><td>进程所需的工作时间（只包括CPU，不包含阻塞、I&#x2F;O等）</td></tr><tr><td>等待时间</td><td>周转时间-运行时间</td></tr><tr><td>带权周转时间</td><td>作业周转时间与作业实际运行时间的比值</td></tr><tr><td>吞吐率</td><td>单位时间内COU完成作业的数量</td></tr></tbody></table><h4 id="②调度算法"><a href="#②调度算法" class="headerlink" title="②调度算法"></a>②调度算法</h4><table><thead><tr><th>算法</th><th>抢占？</th><th>优点</th><th>缺点</th><th>饥饿</th></tr></thead><tbody><tr><td>先来先服务FCFS</td><td>非抢占</td><td>公平，实现简单</td><td>对短作业不利</td><td>不会</td></tr><tr><td>短作业优先SJF</td><td>默认非抢占，其抢占式称为最短剩余时间优先算法SRTN</td><td>SRTN可以实现最短的平均等待&#x2F;周转时间</td><td>对长作业不利，可能导致饥饿</td><td>会</td></tr><tr><td>高响应比优先HRRN</td><td>非抢占</td><td>上述两种算法的权衡</td><td></td><td>不会</td></tr><tr><td>时间片轮转</td><td>抢占</td><td>公平，适用于分时系统</td><td>频繁切换有开销，不区分优先级</td><td>不会</td></tr><tr><td>优先级调度</td><td>抢占&#x2F;非抢占，注意读题</td><td>区分优先级，适用于实时系统</td><td>可能导致饥饿</td><td>会</td></tr><tr><td><strong>多级反馈队列</strong></td><td>抢占</td><td>平衡优秀</td><td>可能导致饥饿</td><td>会</td></tr></tbody></table><h3 id="基本题型"><a href="#基本题型" class="headerlink" title="基本题型"></a>基本题型</h3><h4 id="①调度算法的应用"><a href="#①调度算法的应用" class="headerlink" title="①调度算法的应用"></a>①调度算法的应用</h4><p>给出作业的到达时间、工作时间、优先级等，应用指定的调度算法演绎调度过程<strong>（甘特图）</strong></p><h4 id="②性能评价"><a href="#②性能评价" class="headerlink" title="②性能评价"></a>②性能评价</h4><p>在上方所演绎的调度过程的基础上评价其时间性能（一般比较平均周转时间）</p><h4 id="③多级反馈队列的设计"><a href="#③多级反馈队列的设计" class="headerlink" title="③多级反馈队列的设计"></a>③多级反馈队列的设计</h4><p><em><strong>&#x2F;&#x2F;根据ym所透露的，十有八九就考这个，强烈建议再做一遍</strong></em></p><p>根据所给需求设计多级反馈队列，如</p><p><img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202206131204403.png" alt="image-20220613120405316"></p><p><img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202206131204899.png" alt="image-20220613120415865"></p><p>注意从上一级队列之中下放的是到队尾而并非队首</p><h3 id="阴间题型"><a href="#阴间题型" class="headerlink" title="阴间题型"></a>阴间题型</h3><h4 id="①考察n道作业的批处理系统"><a href="#①考察n道作业的批处理系统" class="headerlink" title="①考察n道作业的批处理系统"></a>①考察n道作业的批处理系统</h4><p>看题设条件，可能作业调度和进程调度同时考，如下题：</p><img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202206131206459.png" alt="image-20220613120615395" style="zoom: 50%;" /><p>破题点：建立两个队列：作业后备队列和进程就绪队列，即实际上进行两级调度，分别应用题给的两种调度算法，答案：</p><img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202206131207647.png" alt="image-20220613120746588" style="zoom:50%;" /><h4 id="②考察保持系统可调度的周期时间-or-工作时间"><a href="#②考察保持系统可调度的周期时间-or-工作时间" class="headerlink" title="②考察保持系统可调度的周期时间 or 工作时间"></a>②考察保持系统可调度的周期时间 or 工作时间</h4><p>考察公式，可处理负载的条件：<br>$$<br>\sum_{i&#x3D;1}^{m}{\frac{C_i}{P_i}&lt;&#x3D;1}<br>$$<br>其中Ci为各个周期事件的周期长，Pi为其每周期工作耗时</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/12/guidance%201/"/>
      <url>/2024/04/12/guidance%201/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/15/f8mtKpCzq1hyFgd.png" alt="image-20210607140624291"></p><p> <img src="https://i.loli.net/2021/06/13/IaBCg87Pnd61x9A.png" alt="image-20210607140950442"></p><p>​这里的外键为空值指的是该属性的<strong>每一个属性值都为空值</strong></p><p>​注意，like中_代表一个字符，汉字要俩</p><p>​聚集函数不可以直接用于where后面自子句条件判断，但是可以用于having子句的判断</p><p>​集合运算要注意:</p><p>​intersect—交</p><p>​union—并</p><p>​except—除去(差)</p><p>​注意order by在使用时，如果是这样的:order by A, B DESC,意思是先按照A升序排列，再按照B降序排列，by A DESC, BDESC,是两个都降序</p><p>COUNT(DISTINCT)</p><p><img src="https://i.loli.net/2021/06/09/gSfZlPU76WT5JKG.png" alt="image-20210609205419499"></p><p>当查询结果来自于多个表时，这时的查询就叫做连接查询</p><p>内连接就是等值的条件连接</p><p><img src="https://i.loli.net/2021/06/13/lA6fxUMNvIng415.png" alt="image-20210610185242668"></p><p>子查询in子句和exists也可以<img src="https://i.loli.net/2021/06/13/9ibmFoYcJWzTgvO.png" alt="image-20210610185509631"></p><p>​<img src="https://i.loli.net/2021/06/13/JIPZf9AkXHtOG7p.png" alt="image-20210610185608312" style="zoom: 50%;" /></p><p>要注意的是联系的exist来表示<strong>全称量词</strong>和<strong>除运算</strong>的方法!!</p><p>除运算的场景：求选修全部课程的学生的姓名和学号</p><p>​<img src="https://i.loli.net/2021/06/13/nQPydsUALKmexvG.png" alt="image-20210610190524397" style="zoom:67%;" /></p><p>​<img src="https://i.loli.net/2021/06/13/UTAdQ2oh1gjKMEp.png" alt="image-20210610190506766" style="zoom: 50%;" /></p><p>表列名别名均可省略as</p><p>子查询也可以当表</p><p>​<img src="https://i.loli.net/2021/06/13/SMmr8wEKGCjZW6e.png" alt="image-20210610190842241" style="zoom:50%;" /></p><p>关系运算符后面也可以接上子查询</p><p>​<img src="https://i.loli.net/2021/06/13/9QJcxROSNz4lWuX.png" alt="image-20210610191558174" style="zoom:67%;" /></p><h1 id="关系数据库理论"><a href="#关系数据库理论" class="headerlink" title="关系数据库理论"></a>关系数据库理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>逻辑结构设计问题:如果把现实世界表达转换为适合于它的数据模型</p><p>实体内部属性间的关系叫做数据依赖</p><p>函数依赖就是指一种某些属性决定另一些属性的这种决定关系(在关系中是最基本的):r上任意两个元组s,t,若s[X]&#x3D;t[X]&#x3D;&#x3D;&#x3D;&gt;s[Y]&#x3D;t[Y]就称Y函数依赖于X</p><p>不声明讨论的都是非平凡的函数依赖</p><p>函数依赖与候选键之间的关系:属性集都完全函数依赖于X，则X就是候选键</p><p>1NF:不含多值属性和内部结构</p><p>2NF:在1NF的基础上，R中每一个非主属性都完全函数依赖于R的任一候选键</p><p>3NF:R中每一个非主属性都不传递依赖于它的任何一个候选键(不存在非主属性的依赖，但是存在主属性之间的依赖)</p><p>BCNF:首先是1NF，其次对于函数依赖集中的所有X-&gt;Y(Y不包含于X)，如果左部都包含R的任一候选键，则R属于BCNF。(只存在依赖于候选键的函数依赖)(彻底分离，消除插入和删除异常，但是可能存在数据冗余)</p><p>给定函数依赖集找候选键的方法:</p> <img src="https://i.loli.net/2021/06/13/ICNi6eqnpSfTaD3.png" alt="image-20210611155023928" style="zoom:50%;" /><h2 id="数据依赖公理以及关系模式的分解"><a href="#数据依赖公理以及关系模式的分解" class="headerlink" title="数据依赖公理以及关系模式的分解"></a>数据依赖公理以及关系模式的分解</h2><h3 id="数据依赖公理"><a href="#数据依赖公理" class="headerlink" title="数据依赖公理:"></a>数据依赖公理:</h3><p>逻辑蕴含规律:自反律，增广律，传递律</p><p>公理三个推论:合并规则，分解规则，伪传递规则</p><p>掌握求函数依赖集中属性闭包的方法</p><p>函数依赖集的等价&#x3D;&#x3D;&#x3D;&gt;依赖集闭包的等价&#x3D;&#x3D;&#x3D;&#x3D;&gt;互相验证函数依赖是否在对方的比包中&#x3D;&#x3D;&#x3D;&gt;每一个依赖中左属性的指定 函数依赖集闭包中是否含有右属性</p><p>最小函数依赖集:右部最简化，左部无多余属性，无多余函数依赖</p><p>计算最小函数依赖集:具体流程对照上面最小函数依赖集的特征</p><h3 id="关系模式的分解"><a href="#关系模式的分解" class="headerlink" title="关系模式的分解:"></a>关系模式的分解:</h3><p>主要是要保证两个特性:无损连接性和依赖保持性</p><h4 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性:"></a>无损连接性:</h4><p>定义:原关系模式的每一个元组等于其在各个分解的关系模式的投影的自然连接</p><h5 id="检验算法1-图表法"><a href="#检验算法1-图表法" class="headerlink" title="检验算法1:图表法"></a>检验算法1:图表法</h5> <img src="https://i.loli.net/2021/06/13/qsZvnd2bmwckBGz.png" alt="image-20210611153320878" style="zoom:50%;" /> <img src="https://i.loli.net/2021/06/13/lNmAvIE5xn3wqjP.png" alt="image-20210611153335178" style="zoom:50%;" /><h5 id="检验算法2-二项分解定理"><a href="#检验算法2-二项分解定理" class="headerlink" title="检验算法2:二项分解定理"></a>检验算法2:二项分解定理</h5> <img src="https://i.loli.net/2021/06/13/2Rmb6cxfCykOPWp.png" alt="image-20210611153827672" style="zoom:50%;" /><h4 id="函数依赖保持性"><a href="#函数依赖保持性" class="headerlink" title="函数依赖保持性:"></a>函数依赖保持性:</h4><p>函数依赖集在属性子集上的投影概念:</p> <img src="https://i.loli.net/2021/06/13/pPiGBstXwo1vN76.png" alt="image-20210611154009254" style="zoom:50%;" /><p>函数依赖保持性的具体判定</p> <img src="https://i.loli.net/2021/06/13/g4BZiW1xPFpaq5H.png" alt="image-20210611154222833" style="zoom:50%;" /><h3 id="具体的关系模式分解算法"><a href="#具体的关系模式分解算法" class="headerlink" title="具体的关系模式分解算法"></a>具体的关系模式分解算法</h3><p>公理:任一关系模式，可以找到一个分解达到3NF,且具有无损连接性和函数依赖保持性。但是对于BCNF和4NF的模式分解的话，可以保证前者，但是无法保证后者。</p><p>两个算法:分解为3NF和BCNF</p><p>3NF目标算法:</p> <img src="https://i.loli.net/2021/06/13/RGnDIurVzgfKeMa.png" alt="image-20210611155338822" style="zoom:50%;" /><p>BCNF目标算法:</p><p>每一次分解之后各个模式的候选键要重新进行计算</p> <img src="https://i.loli.net/2021/06/13/kXcJe75WKgQZwBP.png" alt="image-20210611160034827" style="zoom:50%;" /><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>1.数据流图和数据字典(了解?)</p><p>2.自底向上概念结构设计的步骤:1.抽象数据并设计局部视图  2.逐步集成局部视图，得到全局概念结构</p><p>3.弱实体类型的一个特征是，仅使用该实体类型的属性无法唯一标识每个实体实例</p><p>合并ER图????????</p><p>ER图向关系模式的转换规则如下:</p> <img src="https://i.loli.net/2021/06/13/l4WZ6FpwDJHcQ8u.png" alt="image-20210611164828558" style="zoom:50%;" /> <img src="https://i.loli.net/2021/06/13/BP7vHxJLGF4Dh1M.png" alt="image-20210611164850823" style="zoom:50%;" /><h1 id="数据库保护与事务管理"><a href="#数据库保护与事务管理" class="headerlink" title="数据库保护与事务管理"></a>数据库保护与事务管理</h1><p>1.数据库系统安全模型的组成部分:身份认证，访问控制，视图限制，审计追踪和数据加密。</p><p>2.访问控制的分类:自主访问控制，强制访问控制，基于角色访问控制</p><p>3.自主访问控制在sql中的实现:(主要是权限的管理相关内容:grant, revoke关键字)</p><ul><li><p>表或视图权限的授予:</p><p>​<img src="https://i.loli.net/2021/06/13/TJ1vDH9gdNC82Sk.png" alt="image-20210612201500097" style="zoom: 50%;" /></p><p>with grant option意思是被授权的用户可以把授予他的特权继续授予其他用户</p></li><li><p>表或视图权限的回收:</p>  <img src="https://i.loli.net/2021/06/13/qTa9NyJEGf5LlVS.png" alt="image-20210612201608093" style="zoom:50%;" /></li><li><p>数据库角色的授权</p><p>创建角色(create role)</p><p>给角色进行授权</p><p>再把角色授权给其他角色</p></li></ul><p>剩下的要注意的就是完整性约束的相关内容:</p><p>​主键，外键，域，断言，触发器</p><p>​ 触发器的定义这一模块感觉要问一下老师具体的规范是什么样的</p><p>事务管理</p><p>事务的几个性质:</p><ul><li>原子性: 要么全部成功完成，要么全部都不完成</li><li>一致性: 数据库的每一个更新操作都必须遵循一定的完整性约束</li><li>隔离性: 多个事务内部做了什么事情是不可见的</li><li>持久性: 事务完成之后执行的结果永久在数据库中，永远有效</li></ul><p>数据库的恢复技术</p><p>1.基本单位:事务</p><p>2.可恢复性的基本原理:数据冗余</p><p>数据恢复的具体方法:</p><ul><li><p>数据转储</p><p>定期将整个数据库进行复制和备份</p><p>分为静态存储和动态存储，海量存储和增量存储</p><p>区别就是转储过程和用户事务是否可以并发执行</p><p>后面的分类就是字面意思</p></li><li><p>登记日志文件</p><p>日志文件:记录事务对数据库的更新操作的文件</p><p>以记录为单位，或者以数据块为单位</p><p>登记日志文件的原则:</p><p>​登记的次序严格按照并发事务执行的时间顺序</p><p>​必须先写日志文件，后写数据库，”日记先写原则”</p><p>​</p></li><li><p>检查点恢复技术</p><p>检查点:事务正常执行时，数据库系统按照一定的时间间隔设置检查点，恢复可以恢复到检查点上</p><p>专门在日志中加入检查点记录并定义相关的动作</p></li><li><p>数据库镜像</p></li><li><p>远程备份系统</p></li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>事务并发执行的几种可能错误</p><ul><li><p>丢失修改</p><p>两个事务同时对同一数据进行修改，其中一个事务的提交结果破坏了另一个事务的提交结果，造成修改的丢失</p></li><li><p>不可重复读</p><p>一个事务读取数据后，另一个事务执行更新操作，使前一个事务再次读出的数据和前面不一致</p><p>根据更新操作可以分为三种情况: 修改，删除，和插入</p></li><li><p>脏读</p><p>事务T1修改数据，并写回磁盘，事务T2读取了数据之后，T1又由于某种原因被撤销了，此时数据恢复原值，但是T2读取到的数据同数据库中的数据不一致</p></li></ul><p>锁机制</p><p>​排他锁(X锁):只允许拥有锁的事务进行读取和修改</p><p>​共享锁(S锁):只允许加锁事务修改</p><p>​死锁的诊断和解除:</p><p>​诊断:超时法和等待图法</p><p>​解除:一次封锁法和顺序封锁法</p><p>并发事务执行的可串行化</p><p>​可串行化调度的定义: 多个事务的并发执行是正确的当且仅当其结果与按某一次序串行地执行它们时地结果相同，就称这种调度策略时是可串行化的调度</p><p>两端锁协议</p> <img src="https://i.loli.net/2021/06/13/fQRPOIhEZ5Ylt6N.png" alt="image-20210613135521581" style="zoom: 67%;" /><p>封锁的粒度</p><p>​粒度越小，并发度就越高</p><p>​</p><p>多粒度锁</p><p>意向锁:如果想对一个节点加锁，就要先向其父节点加意向锁</p><p>分为IS,IX,SIX，IS—对子节点想加S锁，IX——对子节点想加X锁，SIX—-对它先加S锁再加IX锁</p><h1 id="注意的事项"><a href="#注意的事项" class="headerlink" title="注意的事项:"></a>注意的事项:</h1><p>分解3NF的时候针对的是Fm, 如果存在X-&gt;A，且XA&#x3D;U则直接是3NF</p><p>分解BCNF的时候针对的是F+!!!!</p><p>求解Fm的时候判断等价性的时候一定要把当前函数依赖去掉再求闭包</p><p>1NF—&gt;2NF:  直接将各个部分函数依赖合起来就行</p><p>1NF的形成条件: 不存在组合属性，不存在内部结构</p><p>R1R2那个二项分解定理是用来检验无损连接性的，检验函数依赖性的方法就那一个</p><p>就是检查F在各个属性集上的投影(算F+里的)并起来是否等于原值</p><p>select语句where子句允许多个AND和多个OR连接</p><p>create trigger grade_tirgger before update on s_c referencing new as x, old as y</p><p>注意这里new和old的as</p><p>书上的grant语句和(ppt上的和mysql中)有出入</p><h1 id="做题时发现要注意的知识点"><a href="#做题时发现要注意的知识点" class="headerlink" title="做题时发现要注意的知识点"></a>做题时发现要注意的知识点</h1><p>1.合并E-R图中的三个冲突的具体含义:</p><p>​属性冲突:  属性域冲突(属性值的类型取值范围或取值集合不同)或者是属性取值单位冲突</p><p>​命名冲突:  (结构是一样的，要是关系都是关系)同名异义(不同意义的对象在不同的局部ER图中具有相同的名字)或者是异名同义(同一意义的对象在不同ER图中有不同的名字)</p><p>​    结构冲突:  同一对象有不同的抽象: eg: 在一个图中当实体,另一个图中当属性</p><p>​   同一实体在不同图中属性的个数和次序不同</p><p>​   实体间的联系在不同的图中不完全相同</p><ol start="2"><li><p>判断3NF中提到了<strong>主属性和非主属性合起来决定非主属性的情况也叫非主属性之间的函数依赖</strong>。</p></li><li><p>数据独立性:  数据与程序间的互不依赖性</p><p>物理独立性:  数据库物理结构的改变不影响逻辑结构及应用程序</p><p>逻辑独立性:数据库逻辑结构的改变不影响应用程序</p><p>数据结构包含逻辑结构和物理结构</p></li><li><p>除法操作</p></li><li><p><strong>group by的一个问题</strong></p><p>之前一直以为select语句中如果有group by那么查询的字段只能是group by后面的字段以及狙聚集函数</p><p><strong>但是实验发现不是这样的!!</strong> 如果分组过后的组内的其他属性的值相同的话，也可以查询，例如</p><p>分组之后有这样的:(按日期分组)</p><table><thead><tr><th>Num</th><th>Date</th></tr></thead><tbody><tr><td>a1</td><td>t1</td></tr><tr><td>a1</td><td>t1</td></tr><tr><td>a1</td><td>t1</td></tr></tbody></table><p>那么select Num, Date from T group by Date</p><p>或者select Numfrom T group by Date都可以</p><p>还是看能否将这一字段的元组按照指定的属性进行分类!!!!</p></li><li><p>概念结构:ER图 ，逻辑结构:关系模型</p></li><li><p>事务控制管理分为两部分:恢复和并发控制</p></li><li><p>数据库系统安全技术:身份认证，访问控制，视图限制，审计追踪和数据加密。</p></li></ol><p>   数据库恢复技术:数据转储，登记日志文件，检查点恢复，数据库镜像，远程备份</p><ol start="11"><li><p>关系代数中的基本运算是并，差，投影，选择和笛卡尔积</p><p>连接可以转换为在笛卡尔积上的选择操作，除运算可以转换为选择和连接</p></li><li><p>可通过视图进行各种数据查询和更新操作(x)，书上说视图的特点之一就是更新有限制</p><p>并且有些视图是无法进行更新的!!-  p86比如把列平均值拿出来当做视图的属性</p></li><li><p>ALL(直接填入列名)是合法的嘛</p></li><li><p>数据库的三级模式体系有利于保持数据库的数据独立性</p></li><li><p>父类子类继承那一部分内容要重点看吗???</p></li><li><p>一个表中只有一个聚簇索引</p></li><li><p>(数据库访问技术)嵌入式sql, 4NF，查询的优化</p></li><li><p><strong>若关系模式R中全部是主属性，则R的最高范式必定是3NF，不可能是BCNF!!!!!</strong></p><p>3NF的不彻底性就表现在于主属性对候选键的部分函数依赖或者是传递函数依赖(会有插入和删除异常)</p><p>而BCNF的定义如下:</p><p><img src="https://i.loli.net/2021/06/15/LyMVKoixDkQY7cq.png" alt="image-20210615093313305"></p><p>这里强调Y不包含于X!!!!, 如果都是主属性的话必然不满足此条件</p><p><strong>类似的，如果R的候选码是一个全码，则R必定是BCNF</strong></p></li><li><p>事务的隔离性是由DBMS的并发控制子系统来实现的</p></li><li><img src="https://i.loli.net/2021/06/15/4YCUOA7caJgMvXd.png" alt="image-20210615094730787" style="zoom:50%;" /><p> 规则可以这样总结:  </p><pre><code>     S:  S,IS _</code></pre><p>​  X:  _</p><p>​  IS:   S,IS,IX,SIX,_</p><p>​  IX:  IX,IS,_</p><p>​  SIX: IS,_</p><p>​</p></li></ol><p></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/12/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2024/04/12/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-有穷自动机-8个算法，确定化、最小化、RG和FA和RE之间的六个转换"><a href="#第三章-有穷自动机-8个算法，确定化、最小化、RG和FA和RE之间的六个转换" class="headerlink" title="第三章  有穷自动机(&#x3D;&#x3D;8个算法，确定化、最小化、RG和FA和RE之间的六个转换&#x3D;&#x3D;)"></a>第三章  有穷自动机(&#x3D;&#x3D;8个算法，确定化、最小化、RG和FA和RE之间的六个转换&#x3D;&#x3D;)</h1><blockquote><p>自动机的概念：自动机是一种能进行<strong>运算</strong>并实现<strong>自我控制</strong>(根据外界的信息改变自己的状态)的装置，计算机就是一部自动机。自动机是描述符号串处理的强有力的工具。<strong>功能：识别语言</strong></p></blockquote><h2 id="3-1-有穷自动机的形式定义"><a href="#3-1-有穷自动机的形式定义" class="headerlink" title="3.1 有穷自动机的形式定义"></a>3.1 有穷自动机的形式定义</h2><h3 id="1、有穷自动机的分类及组成"><a href="#1、有穷自动机的分类及组成" class="headerlink" title="1、有穷自动机的分类及组成"></a>1、有穷自动机的分类及组成</h3><ul><li><p>&#x3D;&#x3D;DFA:&#x3D;&#x3D;  Deterministic Finite (State) Automation，确定的有穷(状态)自动机。当前状态经一个输入到达<strong>下一个</strong>状态。</p></li><li><p>&#x3D;&#x3D;NDFA（or NFA）:&#x3D;&#x3D;  Non Deterministic Finite (State) Automation非确定的有穷自动机。当前状态经一个输入可到达<strong>多个</strong>状态。</p><blockquote><p>FA的等价性： L(A<del>1</del>) &#x3D; L(A<del>2</del>)，则称有穷自动机A<del>1</del>和A<del>2</del>是<strong>等价</strong>的（类比文法等价）</p></blockquote><blockquote><p>关系：<strong>DFA是NDFA的特例</strong>，对每个NDFA N一定存在一个DFA M，使得L(M)&#x3D;L(N)，但这种DFA M可能不唯一。</p><p>q表示状态，Q表示状态集</p><p><strong>用有穷自动机表示无穷：状态转换的回路（文法：递归）</strong></p><p><img src="https://s2.loli.net/2022/03/31/WaIvVMDhmdj1gJL.png" alt="image-20220331234125325"></p></blockquote></li></ul><table><thead><tr><th>DFA &#x3D; (Q，∑，t，&#x3D;&#x3D;q<del>0</del>&#x3D;&#x3D;，F)</th><th>DFA的扩充</th><th>NDFA &#x3D;  (Q，∑，t，&#x3D;&#x3D;Q<del>0</del>&#x3D;&#x3D;，F)</th><th>NDFA 的扩充</th></tr></thead><tbody><tr><td>Q：有穷非空的状态集</td><td></td><td></td><td></td></tr><tr><td>Σ：有穷的输入字母表</td><td></td><td></td><td></td></tr><tr><td>t：<strong>单值映射Q×&#x3D;&#x3D;Σ&#x3D;&#x3D;→Q</strong> 。 t(q, x)&#x3D;q’。可以理解由当前状态和<strong>一个输入字符</strong>得到下一个状态</td><td>t：<em><em>单值映射Q×&#x3D;&#x3D;Σ</em>&#x3D;&#x3D;→Q</em>* 。 t(q, ε) &#x3D; q。t(q, aα) &#x3D; t ( t(q, a),  α)，其中q∈Q， a ∈Σ,  α∈Σ*。可以理解由当前状态和<strong>一个符号串</strong>得到下一个状态</td><td>t：<strong>多值映射Q×&#x3D;&#x3D;Σ&#x3D;&#x3D;→2^Q^</strong>。t(q,x)&#x3D;{q<del>1</del>,q<del>2</del>,…,q<del>n</del>} (状态的幂集)</td><td>t：<em><em>多值映射Q×&#x3D;&#x3D;Σ</em>&#x3D;&#x3D;→2^Q^</em>* 。 t(q, ε)&#x3D;q。t(q, aα) &#x3D; t(q<del>1</del>,α)∪t(q<del>2</del>,α)∪… ∪t(q<del>n</del>,α)，其中 a ∈Σ,  α∈Σ*, t(q, a) &#x3D; {q<del>1</del>, q<del>2</del>… q<del>n</del>}。</td></tr><tr><td><strong>q<del>0</del>：∈Q，是开始状态</strong></td><td></td><td><strong>Q<del>0</del>：⊆Q，是开始状态集</strong>。即使只有一个开始状态，也要用{}</td><td></td></tr><tr><td>F：⊆Q，非空终止状态集合</td><td></td><td></td><td></td></tr><tr><td></td><td>DFA的扩充，使得DFA可以描述对符号串的识别。**如果t(q<del>0</del>, α) ∈ F，则α可被DFA接受(或识别)*<em>，即从开始状态经α可到达某一个终止状态。被DFA A识别的符号串集合，记为L(A)，L(A) &#x3D; {α∈Σ</em> | t(q<del>0</del>, α)  ∈ F}，即这台自动机所能识别和接受的语言。α是L(A)的句子 。</td><td></td><td>NDFA的扩充，使得NDFA可以描述对符号串的识别。**如果q ∈ t(q<del>0</del>, α) , q<del>0</del>∈ Q<del>0</del> ，q∈ F，则α可被DFA接受(或识别)*<em>，即从某一个开始状态经α可到达某一个终止状态。被NDFA A识别的符号串集合，记为L(A)，L(A) &#x3D; {α∈Σ</em> | t(q<del>0</del>, α)  ∩ F ≠ ∅ ,q<del>0</del>∈Q<del>0</del> }</td></tr></tbody></table><h3 id="2、有穷自动机的表示："><a href="#2、有穷自动机的表示：" class="headerlink" title="2、有穷自动机的表示："></a>2、有穷自动机的表示：</h3><ul><li><p>状态转换表</p></li><li><p>状态转换图（<strong>更常用</strong>）</p><blockquote><p>非空终止状态用同心圆表示</p></blockquote></li><li><p>&#x3D;&#x3D;DFA:&#x3D;&#x3D; </p>  <img src="https://s2.loli.net/2022/03/17/dbpaewYO5WZ4yc9.png" alt="image-20220317150650779" style="zoom:67%;" /></li><li><p>&#x3D;&#x3D;NDFA&#x3D;&#x3D;</p>  <img src="https://s2.loli.net/2022/03/17/ZgFyLjveGRzAbwU.png" alt="image-20220317154458730"  /></li></ul><h2 id="3-2-NDFA到DFA的转换（-必考-）"><a href="#3-2-NDFA到DFA的转换（-必考-）" class="headerlink" title="3.2 NDFA到DFA的转换（&#x3D;&#x3D;必考&#x3D;&#x3D;）"></a>3.2 NDFA到DFA的转换（&#x3D;&#x3D;必考&#x3D;&#x3D;）</h2><blockquote><p>DFA是NDFA的特例，对每个NDFA N一定存在一个DFA M，使得L(M)&#x3D;L(N)，但这种DFA M可能不唯一</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">a[NDFA]--&gt;|确定化|b[DFA];</span><br><span class="line">b[DFA]--&gt; |化简|c[最小化的DFA];</span><br><span class="line">c[最小化的DFA] --&gt; d[词法分析程序];</span><br></pre></td></tr></table></figure><h3 id="1、确定化-NDFA-DFA（-注意造表法是可以直接用的，不需要消-varepsilon-）"><a href="#1、确定化-NDFA-DFA（-注意造表法是可以直接用的，不需要消-varepsilon-）" class="headerlink" title="1、确定化:   NDFA -&gt; DFA（&#x3D;&#x3D;注意造表法是可以直接用的，不需要消$\varepsilon$&#x3D;&#x3D;）"></a>1、确定化:   NDFA -&gt; DFA（&#x3D;&#x3D;注意造表法是可以直接用的，不需要消$\varepsilon$&#x3D;&#x3D;）</h3><p>子集法 &#x2F; 造表法（&#x3D;&#x3D;考造表法&#x3D;&#x3D;）</p><ul><li><p>&#x3D;&#x3D;子集法。&#x3D;&#x3D; </p><p>  <strong>步骤：</strong></p><ul><li><p>&#x3D;&#x3D;空移环路的寻找和消除&#x3D;&#x3D;：消除从状态A开始并以A结束的空移动序列(空移环路上的所有状态都是等价的)，把它们合并成一个结点并取公共名。<strong>注意Q<del>0</del>和F</strong>。<strong>注意a弧、b弧等等会变成自环</strong></p><blockquote><p>ε自动机：自动机的弧上允许标记ε，称此FA为ε自动机，记为εFA（εNDFA或εDFA）。εNDFA &#x3D; (Q，∑ ∪{ε}，t，Q<del>0</del>，F)</p><p>消除ε自动机中的空移：对于εFA ，总可以构造等价的FA，使得L (εFA) &#x3D; L(FA)</p></blockquote></li><li><p>&#x3D;&#x3D;消除余下的空移&#x3D;&#x3D;： εNDFA -&gt; NDFA。<strong>去ε弧、添等价弧(包括ε弧)、置特殊状态（终态必须置，初态可以不置）</strong></p></li></ul><p>  <img src="https://s2.loli.net/2022/03/17/6ADyZeGocNvkCr7.png" alt="image-20220317165134820"></p><ul><li><p>&#x3D;&#x3D;利用子集法确定化&#x3D;&#x3D;   NDFA  -&gt; DFA</p><p>  思想：把从状态到状态的多值映射转化为状态集到状态集的单值映射</p><p>  <img src="https://s2.loli.net/2022/03/17/mr486kDGcZIheNl.png" alt="image-20220317170543983"></p></li></ul><blockquote><p>子集法的正确性的证明：α∈L(A)当且仅当α∈L(A’)</p><p>DFA:从开始状态（是一个状态类）到某一个终止状态子集，NFA：从某一个开始状态到某一个终止状态，这两个映射是可以转换的</p></blockquote><p>  <strong>局限性：</strong>状态数太多（2^Q^ - 1个状态，存储和查找的开销大）、存在不可达状态（挂起）</p><p>  <strong>例子：</strong></p><p>  <img src="https://s2.loli.net/2022/03/24/dEcwUWZuGxOsYDF.png" alt="image-20220324214849272"></p><hr></li><li><p>&#x3D;&#x3D;造表法（考）&#x3D;&#x3D;(造表法本质还是子集法，子集法和造表法统称为子集法  )</p><ul><li><p><strong>思想</strong>：为避免不可达状态，从初始状态出发，计算t′，依次构造其后继状态，进行确定化。</p><blockquote><p>一些概念：</p><ul><li><strong>I<del>a</del><strong>：I<del>a</del> &#x3D; t’(I, a)，即从I中的状态出发经过一条a弧（可跳过a弧</strong>前后</strong>的任意条ε弧）到达的状态集合</li><li><strong>状态子集I的ε闭包（ ε-CLOSURE(I) ）</strong>：包含了I中的状态和它们经过任意条ε弧能到达的Q中的状态</li><li><strong>I<del>a</del>子集</strong>：即从I中的状态出发，经过一条a弧（可跳过a弧<strong>前</strong>的任意条ε弧）到达的状态集合，称为<strong>J</strong>。I<del>a</del> &#x3D; ε-CLOSURE(J)</li></ul></blockquote></li><li><p><strong>步骤：</strong></p><p>  <img src="https://s2.loli.net/2022/03/17/voLRXMOuwQh8KlJ.png" alt="image-20220317182540359"></p></li><li><p><strong>特点</strong>：简单有效、不存在不可达状态、状态数比子集法大大减少</p></li><li><p>例子：</p>  <img src="https://s2.loli.net/2022/03/24/NXDbZx2z1VdTJLK.png" alt="image-20220324215954121" style="zoom:67%;" />  <img src="https://s2.loli.net/2022/03/24/B9zabF2JuGSEV13.png" alt="image-20220324215944493" style="zoom: 50%;" /></li></ul></li></ul><h3 id="2、最小化：DFA-MFA"><a href="#2、最小化：DFA-MFA" class="headerlink" title="2、最小化：DFA -&gt; MFA"></a>2、最小化：DFA -&gt; MFA</h3><ul><li><p>目标：寻找等价的、状态数更少的DFA M’（M’是唯一的）</p></li><li><p><strong>思想：合并等价状态、删除无关状态</strong></p><blockquote><p><code>等价状态：</code>从两个状态出发可以识别同一个字符串(任意一个)到达终态，则称这两个状态是等价的，否则称它们是可区分的。即$$\forall\alpha\epsilon\Sigma^*, t(q, \alpha)\epsilon F当且仅当t(q’, \alpha)\epsilon F$$</p></blockquote></li><li><p>最小化算法（划分法）：把状态集划分成若干个互不相交的等价状态集</p><p>  步骤：</p><ul><li><p>构造状态集的划分，&#x3D;&#x3D;从终止状态集和非终止状态集里再细分&#x3D;&#x3D;（因此最终至少有两个状态）</p></li><li><p>取每组中的一个状态作代表，合并等价状态。</p><blockquote><p>例如，A和B是等价状态，则如果选A为代表而删除B，则应<strong>将射入B的弧补到A上</strong>，<strong>不需要补射出B的弧</strong>，因为由等价状态的定义可知，A和B的射出的弧到达的下一个状态是相同的</p></blockquote></li><li><p>删去无关状态，包括不可达状态和死状态等</p><p>  <img src="https://s2.loli.net/2022/03/17/owSlZ7rmcPRtM2A.png" alt="image-20220317220019401"></p></li></ul></li><li><p>例子：</p><p>  <img src="https://s2.loli.net/2022/03/24/9kuErAlD1L76efa.png" alt="image-20220324221541448"></p></li></ul><p><img src="https://s2.loli.net/2022/03/24/RDnC9dptK1QNkXu.png" alt="image-20220324221835671"></p><h3 id="3、从化简后的DFA到程序表示-MFA-scanner"><a href="#3、从化简后的DFA到程序表示-MFA-scanner" class="headerlink" title="3、从化简后的DFA到程序表示 MFA -&gt; scanner"></a>3、从化简后的DFA到程序表示 MFA -&gt; scanner</h3><p><img src="https://s2.loli.net/2022/03/24/QnbFtWksm9KjPAc.png" alt="image-20220324222006003"></p><h2 id="3-3-正规文法-RG-与FA"><a href="#3-3-正规文法-RG-与FA" class="headerlink" title="3.3 正规文法(RG)与FA"></a>3.3 正规文法(RG)与FA</h2><h3 id="1、RG与FA"><a href="#1、RG与FA" class="headerlink" title="1、RG与FA"></a>1、RG与FA</h3><ul><li>RG是语言的生成规则</li><li>FA识别（接受）语言</li></ul><h3 id="2、RG-FA："><a href="#2、RG-FA：" class="headerlink" title="2、RG -&gt; FA："></a>2、RG -&gt; FA：</h3><p>由正规文法G[S]可直接构造一个与之等价的FA A，使得L(G)&#x3D;L(A)。</p><p><strong>步骤：</strong></p><ul><li><p>令G的终结符号集V<del>T</del>为A的字母表∑； </p></li><li><p>G的非终结符号作为A的状态，G的开始符号为A的开始状态； </p></li><li><p>&#x3D;&#x3D;增加一个终止状态Z（Z ∉ V<del>N</del>）；&#x3D;&#x3D;</p></li><li><p>形如U→a的规则，引一条从状态U到终止状态Z的标记为a的弧； </p></li><li><p>形如U→aW的规则，引一条从状态U到W的a弧</p><p>  对应关系如下：</p><table><thead><tr><th>G[S]&#x3D;（V<del>N</del>，V<del>T</del>，P，S）</th><th>NFA &#x3D; (Q，∑，t，{q<del>0</del>}，F) (初态唯一,因为要和S对应)</th></tr></thead><tbody><tr><td>V<del>N</del></td><td>Q</td></tr><tr><td>V<del>T</del></td><td>∑</td></tr><tr><td>P</td><td>t，形如U→a的规则，引一条从状态U到终止状态Z的标记为a的弧；     形如U→aW的规则，引一条从状态U到W的a弧（特别地，如果有形如U→aU的规则，引一条从状态U到状态U的自环）</td></tr><tr><td>S</td><td>q<del>0</del></td></tr><tr><td></td><td><strong>F(新增加的，∉ V<del>N</del>)</strong></td></tr></tbody></table></li></ul><p>&#x3D;&#x3D;eg.&#x3D;&#x3D;</p><p><img src="https://s2.loli.net/2022/03/31/joSRI4KyDEards1.png" alt="image-20220331230128319"></p><p><img src="https://s2.loli.net/2022/03/31/7YVoTF6COnZKIJR.png" alt="image-20220331231013992"></p><h3 id="3、FA-RG"><a href="#3、FA-RG" class="headerlink" title="3、FA -&gt; RG"></a>3、FA -&gt; RG</h3><p>由有穷自动机FA A可直接构造一个与之等价的正规文法G，使得L(G)&#x3D;L(A)</p><p><strong>步骤：</strong></p><ul><li><p>自动机A中的每一个状态均作为G的非终结符号，其中A的开始状态作为G的开始符号，A的输入字母表∑中的所有符号作为G的终结符号；</p></li><li><p>对A中V ∈ t(U,a)的映射，构造G的产生式U∷&#x3D;aV；若V∈F，则构造G的产生式 U::&#x3D;a；</p></li><li><p>若A中q<del>0</del>∈F，则构造G的产生式S∷&#x3D;ε</p><p>  对应关系如下：</p><table><thead><tr><th>DFA &#x3D; (Q，∑，t，q<del>0</del>，F)</th><th>G[S]&#x3D;（V<del>N</del>，V<del>T</del>，P，S）</th></tr></thead><tbody><tr><td>Q</td><td>V<del>N</del></td></tr><tr><td>∑</td><td>V<del>T</del></td></tr><tr><td>t</td><td>P，对A中V ∈ t(U,a)的映射，构造G的产生式U∷&#x3D;aV；<br />若V∈F，则构造G的产生式 U::&#x3D;a；<br />若A中q<del>0</del>∈F，则构造G的产生式S∷&#x3D;ε</td></tr><tr><td>q<del>0</del></td><td>S</td></tr><tr><td>F</td><td></td></tr></tbody></table></li></ul><p>&#x3D;&#x3D;eg.&#x3D;&#x3D;</p><p><img src="https://s2.loli.net/2022/03/31/bZth9rlPiADF12E.png" alt="image-20220331231121040"></p><p><img src="https://s2.loli.net/2022/03/31/Tqyr9uzPmBH3pFL.png" alt="image-20220331231701572"></p><h2 id="3-4-正规表达式-正则表达式-RE-与FA"><a href="#3-4-正规表达式-正则表达式-RE-与FA" class="headerlink" title="3.4 正规表达式&#x2F;正则表达式(RE)与FA"></a>3.4 正规表达式&#x2F;正则表达式(RE)与FA</h2><h3 id="1、RE（可以直观地描述出语言的特征）"><a href="#1、RE（可以直观地描述出语言的特征）" class="headerlink" title="1、RE（可以直观地描述出语言的特征）"></a>1、RE（可以直观地描述出语言的特征）</h3><ul><li><p>&#x3D;&#x3D;概念：&#x3D;&#x3D; </p><p>  三种运算：或运算 a|b 、连接运算 ab、闭包运算 a^<em>^(正闭包a^+^)。*<em>（优先级由低到高）</em></em></p><p>  &#x3D;&#x3D;注意在RE中，0个或无穷多个不是用{}来表示，而是用*来表示，大括号是集合&#x3D;&#x3D;</p></li></ul><p><img src="https://s2.loli.net/2022/03/31/5pFHox1ryEjbhTw.png" alt="image-20220331231923652"></p><p><strong>eg.</strong></p><p><img src="https://s2.loli.net/2022/03/31/YozVNxEDCfHuWy2.png" alt="image-20220331232616611"></p><img src="https://s2.loli.net/2022/03/31/1dEyrHmjPx54nhX.png" alt="image-20220331233246560" style="zoom:50%;" /><ul><li><p>&#x3D;&#x3D;RE等价：&#x3D;&#x3D; 设e<del>1</del>，e<del>2</del>均为∑上的正规表达式，若 L(e<del>1</del>)&#x3D;L(e<del>2</del>)，则称e<del>1</del>与e<del>2</del>等价，记为：e<del>1</del>&#x3D; e<del>2</del></p><p>  <img src="https://s2.loli.net/2022/03/31/P3IEHFbZvWhRwYr.png" alt="image-20220331233053138"></p><p>  <img src="https://s2.loli.net/2022/03/31/QWnVp9zkxHY2MoZ.png" alt="image-20220331233112495"></p></li><li><p>&#x3D;&#x3D;RE的性质：&#x3D;&#x3D; </p><p>  <img src="https://s2.loli.net/2022/03/31/Xjo15J2dBLHhYC3.png" alt="image-20220331232826488"></p></li></ul><h3 id="2、RE-–-FA"><a href="#2、RE-–-FA" class="headerlink" title="2、RE –&gt; FA"></a>2、RE –&gt; FA</h3><p>对于字母表Σ上的任意正规表达式e，一定可以构造一个输入字母表Σ上的<strong>NDFA A</strong>，使得L(A)&#x3D;L(e)</p><p><strong>步骤：</strong></p><ul><li><p>构造广义NFA：<strong>S是惟一开始状态，Z是惟一终止状态</strong>。弧标记e。</p></li><li><p>根据分解规则分解e ，得到与e对应的NFA。</p><p>  分解规则如下：</p><p>  <img src="https://s2.loli.net/2022/03/17/uoEaYrUIJ8gFxbj.png" alt="image-20220317230004987"></p></li></ul><p>&#x3D;&#x3D;eg&#x3D;&#x3D;</p><p><img src="https://s2.loli.net/2022/03/31/p6tFHduCrOm1oL5.png" alt="image-20220331233904038"><img src="https://s2.loli.net/2022/03/31/Q7WpazfkA3UgZwi.png" alt="image-20220331233938288" style="zoom:67%;" /></p><h3 id="3、FA-RE"><a href="#3、FA-RE" class="headerlink" title="3、FA -&gt; RE"></a>3、FA -&gt; RE</h3><ul><li><p>由有穷自动机FA A所识别的语言L(A)，可以用Σ上 的RE e来表示，使得L(A)&#x3D;L(e)</p><p>  <strong>步骤</strong></p></li><li><p>（&#x3D;&#x3D;当初态和终态不唯一时&#x3D;&#x3D;）在FA A的状态图中增加两个结点：<strong>S是惟一开始状态</strong>，从S向原开始状态连ε弧；<strong>Z是惟一终止状态</strong>，从原终止状态向Z连ε弧。</p></li><li><p>利用下列替换规则逐步消去状态图中的结点和弧，直至仅剩下S到Z的一条弧为止，则该弧上的标记即为RE e。</p><p>  <img src="https://s2.loli.net/2022/03/17/tVZi5aIBq1HJ6P9.png" alt="image-20220317230404452"></p></li></ul><p>&#x3D;&#x3D;eg&#x3D;&#x3D;</p><img src="https://s2.loli.net/2022/03/31/YdrHoz6ZUMKlbIk.png" alt="image-20220331234216167" style="zoom:67%;" /><img src="https://s2.loli.net/2022/03/31/rsiz7VASouyqd6H.png" alt="image-20220331234837905" style="zoom:50%;" /><h2 id="3-5-RE与RG"><a href="#3-5-RE与RG" class="headerlink" title="3.5 RE与RG"></a>3.5 RE与RG</h2><h3 id="1、RG-RE"><a href="#1、RG-RE" class="headerlink" title="1、RG -&gt; RE"></a>1、RG -&gt; RE</h3><p>对任何一个正规文法G，都存在一个等价的正规表达式e，使得L(e)&#x3D;L(G)</p><blockquote><p>正规文法的拓广：产生式的形式为 U→αV 或 U→α， α为可空字符串，即<strong>右线性文法，</strong>容易改写成RG。</p></blockquote><p><strong>由右线性文法到正规表达式的转换规则：</strong></p><ul><li>形如U→αV, V→β的产生式转换成正规表达式U &#x3D; αβ；</li><li>&#x3D;&#x3D;形如U→αU|β的产生式转换成U &#x3D; α*β；&#x3D;&#x3D;</li><li>形如U→α|β的产生式转换成U &#x3D; α|β。</li><li>反复使用上述三条规则，直到文法只剩下一条关于文法开始符号的产生式，且该条产生式的右部不含非终结符号。这个产生式的右部就是正规表达式。</li></ul><p><strong>例子：</strong></p><img src="https://s2.loli.net/2022/04/07/mjVd8KzNpU5EICS.png" alt="image-20220407223903410" style="zoom:67%;" /><img src="https://s2.loli.net/2022/04/07/ef5n4uIJqNZTc6P.png" alt="image-20220407224157566" style="zoom: 50%;" /><h3 id="2、RE-RG"><a href="#2、RE-RG" class="headerlink" title="2、RE -&gt; RG"></a>2、RE -&gt; RG</h3><p>直接转换较困难，可通过FA来间接转换</p><p><strong>规则：</strong></p><ul><li><p>令RG为G[S] ，对RE e，形成产生式S→e ；</p></li><li><p>利用下列替换规则，重写产生式，直至符合RG形式要求： </p><ul><li><p>A→xy       替换成   A→xB ， B→y (新增B ∈ V<del>N</del>) </p></li><li><p>A→x*y     替换成   A→xA | y</p></li><li><p>A→x | y   替换成   A→x ， A→y</p><p>  即得所求之RG G[S]。</p></li></ul></li></ul><p><strong>例子：</strong></p><p><img src="https://s2.loli.net/2022/04/07/YJ6rljcPZOHA5kz.png" alt="image-20220407225050765"></p><img src="https://s2.loli.net/2022/04/07/TzrkhKHd2lDIoiV.png" alt="image-20220407225042766" style="zoom:50%;" /><h2 id="3-6-RG、FA、RE三者关系"><a href="#3-6-RG、FA、RE三者关系" class="headerlink" title="3.6 RG、FA、RE三者关系"></a>3.6 RG、FA、RE三者关系</h2><img src="https://s2.loli.net/2022/03/31/evJchpxWLl6E8fb.png" alt="image-20220331201340852" style="zoom:50%;" /><p><img src="https://s2.loli.net/2022/03/31/TEmsJP1gAUjzN7n.png" alt="image-20220331234446610"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/10/%E5%BE%AE%E8%A7%86%E9%A2%91%E5%89%A7%E6%9C%AC/"/>
      <url>/2024/04/10/%E5%BE%AE%E8%A7%86%E9%A2%91%E5%89%A7%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="扶贫主题。。。-标题是啥"><a href="#扶贫主题。。。-标题是啥" class="headerlink" title="扶贫主题。。。(标题是啥)"></a>扶贫主题。。。(标题是啥)</h1><p>中国式现代化是全体人民共同富裕的现代化</p><h2 id="ACT-I"><a href="#ACT-I" class="headerlink" title="ACT I"></a>ACT I</h2><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p>环境展示（可能是某种山村航拍视频）</p><h3 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h3><p>（说明中国式现代化）</p><h2 id="ACT-II"><a href="#ACT-II" class="headerlink" title="ACT II"></a>ACT II</h2><h3 id="Theme-1"><a href="#Theme-1" class="headerlink" title="Theme"></a>Theme</h3><p>新上任的书记（毕业生，青年为共同富裕作出贡献）</p><h3 id="Lines-1"><a href="#Lines-1" class="headerlink" title="Lines"></a>Lines</h3><p>（书记和父亲散步）</p><p><strong>书记：</strong><br>爸，这事儿那就这么定了，那小康村虽然环境不是很好，但我了解到那边有一户村民的祖传配方，专治跌打损伤。这个条件好好利用，最后一定能出成果的！</p><p><strong>书记父亲：</strong><br>嘿，你小子还知道专门做功课说服你爸……行，我同意你走那边，到了那边要注意安全知道不？</p><p><strong>书记：</strong><br>知道知道，我会注意的。</p><p>（转场）</p><h2 id="ACT-III"><a href="#ACT-III" class="headerlink" title="ACT III"></a>ACT III</h2><h3 id="Theme-2"><a href="#Theme-2" class="headerlink" title="Theme"></a>Theme</h3><p>书记从村长那里听说有一家村民有一套祖传秘方，专治跌打损伤，如果可作商用必能在脱贫攻坚战中起到奇效。但传承人不肯将配方轻易示人，上门劝说，不得法，无果。。。（精准扶贫方略）</p><h3 id="Lines-2"><a href="#Lines-2" class="headerlink" title="Lines"></a>Lines</h3><p><strong>书记：</strong><br>有人吗有人吗？麻烦开一下门呗？</p><p>（配方传承人兄弟去开门）</p><p><strong>兄弟：</strong><br>村长，这位是……？</p><p><strong>村长：</strong><br>哦，这位是给咱们村扶贫、新来的书记！</p><p><strong>兄弟：</strong><br>来，这边请，里边儿坐。</p><p>哎呀，听说您是专门来我们小康村扶贫的，我自己是很高兴的……<br>可是我那兄弟就……唉，上回村长来跟他谈了整整一个小时……</p><p><strong>村长：</strong><br>一小时过十四分钟。那哥们还挺倔的，说什么都不听！</p><p><strong>书记：</strong><br>诶，小声点，怎么这么没礼貌！</p><p><strong>兄弟：</strong><br>哥，您看谁来了哥！</p><p>（传承人出场）</p><p><strong>传承人：</strong><br>你还来，你还来！我都说了，我是不会把配方交出来的！快走快走！（扭头甩手）</p><p><strong>村长：</strong><br>诶你这人什么态度！（指传承人）</p><p><strong>书记：</strong><br>村长，出去！到门口等我。（指门口）</p><p><strong>兄弟：</strong><br>（指坐地）书记您坐，俺去给您倒杯水来！</p><p><strong>书记：</strong><br>啊好，谢谢了！（拱手）</p><p>这位同志，你恐怕不知道啊，这手头上就有一个发家致富的金钥匙啊<strong>：就是</strong>你现在拥有的那套中药配方。我目前了解到的情况呢，就是这套配方针对跌打损伤的治疗效果比目前市面上那些药物的都要好。那假如你把这个配方交给离我们这儿最近的制药厂，让他们帮助批量化生产，村民们再结合咱们当地的药材资源，大家不就可以<em>共同富裕</em>起来了吗？</p><p><strong>传承人：</strong><br>（看向书记）不行！俺们家这传了几百年的配方，哪里能轻易给了你们！（捶大腿）</p><p><strong>兄弟：</strong><br>别这样啊哥，俺知道哥你是怀有慈悲之心，是村里的大善人，也一直想帮助更多的人。咱们村里人受了啥伤，都上俺们这儿来靠这药来治。咱们村书记也是为了让俺们家这药呢，能帮助更多的人、让咱们村里富起来，你就答应他吧，哥！（哀求）</p><p><strong>传承人：</strong><br>我还是对你们这些人不放心！俺们家祖祖辈辈传下来的配方就这么给出去？没门！（站起，逐客）走走走，你下次也别来了！（推书记）</p><p>快走！（关门，转身）</p><p><strong>村长：</strong><br>（在门口看书记被推出门外）诶书记，您怎么……也出来了……嗯？</p><p><strong>书记：</strong><br>唉……</p><p><strong>传承人：</strong><br>（对兄弟）别听他瞎说，咱家的配方，可不能给外人晓得了！晓得不？</p><p>（镜头转）</p><h2 id="ACT-IV"><a href="#ACT-IV" class="headerlink" title="ACT IV"></a>ACT IV</h2><h3 id="Theme-3"><a href="#Theme-3" class="headerlink" title="Theme"></a>Theme</h3><p>书记与其作为老党员的父亲通了电话，渐渐掌握了与群众沟通的方法（表现党员传承、群众路线）</p><h3 id="Lines-3"><a href="#Lines-3" class="headerlink" title="Lines"></a>Lines</h3><p>（镜头转）</p><p><strong>村长：</strong><br>这家伙……怎么这么难讲啊！我都想放弃了……真是的……</p><p><strong>书记：</strong><br>这可不行，党交给我们党员的任务就是带领全体人民走向共同富裕。我们国家人口众多，要想实现共同富裕的现代化奋斗目标，就一个都不能落下。这就是我们的责任，如何能轻言放弃呢……</p><p>你这位同志也是，工作这么暴躁，我们党员就要起到先锋带头……</p><p><strong>村长：</strong><br>行行行，你就说怎么办吧（</p><p><strong>书记：</strong><br>这个嘛……等我回去再想想办法（</p><p>（镜头转书记一人在树下沉思，此时电话铃响）</p><p><strong>书记：</strong><br>喂，爸，您怎么打电话来了啊，我这边工作……</p><p><strong>书记父亲：</strong><br>知道你工作忙，哎，但这不是马上端午了嘛，有空回来一趟不？</p><p><strong>书记：</strong><br>端午……先不说这个了，爸，我这边遇上了点事儿……</p><p><strong>书记父亲：</strong><br>喔，是你的扶贫工作遇到困难了？</p><p><strong>书记：</strong><br>哎，还真是什么都瞒不过您……您这方面工作经验丰富，想问问您会怎么处理……</p><p>（假装讨论）</p><p><strong>书记父亲：</strong><br>诶这就对了嘛，只要思想不滑坡，办法总比困难多！你这小子别忘了，你爸我也算老党员了，什么风浪没见过。我们党员干部做工作就一定要结合具体实际，与人民群众站在一起。你这几天呢可以走访当地群众，多了解了解你们那边的具体情况，然后再设计合理的方案。多为人民着想、为人民服务，才能对症下药。</p><p><strong>书记：</strong><br>好的，爸，我知道怎么办了，端午前忙完这事儿我就回去！</p><h2 id="ACT-V"><a href="#ACT-V" class="headerlink" title="ACT V"></a>ACT V</h2><h3 id="Theme-4"><a href="#Theme-4" class="headerlink" title="Theme"></a>Theme</h3><p>书记与村长再次登门拜访，经过长久的理性劝说，终于让配方传承人同意合作。</p><h3 id="Lines-4"><a href="#Lines-4" class="headerlink" title="Lines"></a>Lines</h3><p>（书记和村长敲门）</p><p><strong>兄弟：</strong><br>诶来了来了！书记您快请进，俺相信这回我哥一定能被您打动的！我去叫他……</p><p><strong>书记：</strong><br>哎，这位同志，多谢了！</p><p>（镜头转）</p><p><strong>书记：</strong><br>（对传承人）同志啊，你看，现在这方案怎么样啊？有什么问题，你尽管提！</p><p><strong>传承人：</strong><br>（连连点头）哎呀，这确实是很好咧！早这样说不就好了么！这下我该多谢书记喽！</p><p><strong>书记：</strong><br>哈哈哈，同志你觉得好就好！村长，我们就这么办！</p><h2 id="ACT-VI"><a href="#ACT-VI" class="headerlink" title="ACT VI"></a>ACT VI</h2><h3 id="Theme-5"><a href="#Theme-5" class="headerlink" title="Theme"></a>Theme</h3><p>小康村实现全面小康，作为书记在到县里汇报工作的路上，也顺便回家探亲。但却在路途中遭遇山洪暴发，因公殉职……（致敬在扶贫攻坚路上牺牲巨大的工作者们……）</p><h3 id="Lines-5"><a href="#Lines-5" class="headerlink" title="Lines"></a>Lines</h3><p><strong>书记：</strong><br>（打电话）好好好，我现在坐车呢，应该马上就到了……诶，这前面感觉不太对劲儿啊，先不跟你说了……</p><p>（新闻播报）</p><h2 id="ACT-VII"><a href="#ACT-VII" class="headerlink" title="ACT VII"></a>ACT VII</h2><h3 id="Theme-6"><a href="#Theme-6" class="headerlink" title="Theme"></a>Theme</h3><p>数据视频……</p><h3 id="Lines-6"><a href="#Lines-6" class="headerlink" title="Lines"></a>Lines</h3><p>无（配音？）</p><h2 id="ACT-VIII"><a href="#ACT-VIII" class="headerlink" title="ACT VIII"></a>ACT VIII</h2><h3 id="Theme-7"><a href="#Theme-7" class="headerlink" title="Theme"></a>Theme</h3><p>谢幕</p><h3 id="Lines-7"><a href="#Lines-7" class="headerlink" title="Lines"></a>Lines</h3><p>（演职员表）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/30/%E6%96%B0%E5%BB%BA%20Markdown%20file/"/>
      <url>/2024/03/30/%E6%96%B0%E5%BB%BA%20Markdown%20file/</url>
      
        <content type="html"><![CDATA[<p>关系R的属性全是主属性，则R至少是3NF。</p><p>全键关系至少是BCNF。</p><p>视图建立后，数据字典中存储视图的定义。</p><p>日志文件的主要内容是对数据的全部更新操作。</p><p>数据库控制保护的主要内容：安全性、完整性、并发控制、恢复</p><p>视图是由基本表或视图产生的新表。</p><p> 视图提高了数据库系统的逻辑独立性，安全性</p><p>模式&#x2F;内模式映保证物理独立性，子模式&#x2F;模式映像保证逻辑独立性。</p><p>数据抽象的内容是：分类、概括、聚集</p><p>2NF基本可以消除插入异常</p><p>数据库中产生数据不一致的根本原因是数据冗余。</p><p>二元关系一定是BCNF。</p><h4 id="利用SQL实现该数据库三类完整性约束的方法"><a href="#利用SQL实现该数据库三类完整性约束的方法" class="headerlink" title="利用SQL实现该数据库三类完整性约束的方法"></a>利用SQL实现该数据库三类完整性约束的方法</h4><p>SQL中通过定义主码实现实体完整性；</p><p>通过定义外码实现参照完整性；</p><p>通过定义域约束、检查约束、断言、触发器等实现用户定义的完整性。</p><h4 id="为了提高该数据库的查询效率，可以采取的措施"><a href="#为了提高该数据库的查询效率，可以采取的措施" class="headerlink" title="为了提高该数据库的查询效率，可以采取的措施"></a>为了提高该数据库的查询效率，可以采取的措施</h4><p>建索引、建聚簇</p><p>选择运算尽可能先做</p><p>在执行连接前对关系适当地预处理</p><p>关系的水平、垂直分解等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/30/guidance/"/>
      <url>/2024/03/30/guidance/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/15/f8mtKpCzq1hyFgd.png" alt="image-20210607140624291"></p><p> <img src="https://i.loli.net/2021/06/13/IaBCg87Pnd61x9A.png" alt="image-20210607140950442"></p><p>​这里的外键为空值指的是该属性的<strong>每一个属性值都为空值</strong></p><p>​注意，like中_代表一个字符，汉字要俩</p><p>​聚集函数不可以直接用于where后面自子句条件判断，但是可以用于having子句的判断</p><p>​集合运算要注意:</p><p>​intersect—交</p><p>​union—并</p><p>​except—除去(差)</p><p>​注意order by在使用时，如果是这样的:order by A, B DESC,意思是先按照A升序排列，再按照B降序排列，by A DESC, BDESC,是两个都降序</p><p>COUNT(DISTINCT)</p><p><img src="https://i.loli.net/2021/06/09/gSfZlPU76WT5JKG.png" alt="image-20210609205419499"></p><p>当查询结果来自于多个表时，这时的查询就叫做连接查询</p><p>内连接就是等值的条件连接</p><p><img src="https://i.loli.net/2021/06/13/lA6fxUMNvIng415.png" alt="image-20210610185242668"></p><p>子查询in子句和exists也可以<img src="https://i.loli.net/2021/06/13/9ibmFoYcJWzTgvO.png" alt="image-20210610185509631"></p><p>​<img src="https://i.loli.net/2021/06/13/JIPZf9AkXHtOG7p.png" alt="image-20210610185608312" style="zoom: 50%;" /></p><p>要注意的是联系的exist来表示<strong>全称量词</strong>和<strong>除运算</strong>的方法!!</p><p>除运算的场景：求选修全部课程的学生的姓名和学号</p><p>​<img src="https://i.loli.net/2021/06/13/nQPydsUALKmexvG.png" alt="image-20210610190524397" style="zoom:67%;" /></p><p>​<img src="https://i.loli.net/2021/06/13/UTAdQ2oh1gjKMEp.png" alt="image-20210610190506766" style="zoom: 50%;" /></p><p>表列名别名均可省略as</p><p>子查询也可以当表</p><p>​<img src="https://i.loli.net/2021/06/13/SMmr8wEKGCjZW6e.png" alt="image-20210610190842241" style="zoom:50%;" /></p><p>关系运算符后面也可以接上子查询</p><p>​<img src="https://i.loli.net/2021/06/13/9QJcxROSNz4lWuX.png" alt="image-20210610191558174" style="zoom:67%;" /></p><h1 id="关系数据库理论"><a href="#关系数据库理论" class="headerlink" title="关系数据库理论"></a>关系数据库理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>逻辑结构设计问题:如果把现实世界表达转换为适合于它的数据模型</p><p>实体内部属性间的关系叫做数据依赖</p><p>函数依赖就是指一种某些属性决定另一些属性的这种决定关系(在关系中是最基本的):r上任意两个元组s,t,若s[X]&#x3D;t[X]&#x3D;&#x3D;&#x3D;&gt;s[Y]&#x3D;t[Y]就称Y函数依赖于X</p><p>不声明讨论的都是非平凡的函数依赖</p><p>函数依赖与候选键之间的关系:属性集都完全函数依赖于X，则X就是候选键</p><p>1NF:不含多值属性和内部结构</p><p>2NF:在1NF的基础上，R中每一个非主属性都完全函数依赖于R的任一候选键</p><p>3NF:R中每一个非主属性都不传递依赖于它的任何一个候选键(不存在非主属性的依赖，但是存在主属性之间的依赖)</p><p>BCNF:首先是1NF，其次对于函数依赖集中的所有X-&gt;Y(Y不包含于X)，如果左部都包含R的任一候选键，则R属于BCNF。(只存在依赖于候选键的函数依赖)(彻底分离，消除插入和删除异常，但是可能存在数据冗余)</p><p>给定函数依赖集找候选键的方法:</p> <img src="https://i.loli.net/2021/06/13/ICNi6eqnpSfTaD3.png" alt="image-20210611155023928" style="zoom:50%;" /><h2 id="数据依赖公理以及关系模式的分解"><a href="#数据依赖公理以及关系模式的分解" class="headerlink" title="数据依赖公理以及关系模式的分解"></a>数据依赖公理以及关系模式的分解</h2><h3 id="数据依赖公理"><a href="#数据依赖公理" class="headerlink" title="数据依赖公理:"></a>数据依赖公理:</h3><p>逻辑蕴含规律:自反律，增广律，传递律</p><p>公理三个推论:合并规则，分解规则，伪传递规则</p><p>掌握求函数依赖集中属性闭包的方法</p><p>函数依赖集的等价&#x3D;&#x3D;&#x3D;&gt;依赖集闭包的等价&#x3D;&#x3D;&#x3D;&#x3D;&gt;互相验证函数依赖是否在对方的比包中&#x3D;&#x3D;&#x3D;&gt;每一个依赖中左属性的指定 函数依赖集闭包中是否含有右属性</p><p>最小函数依赖集:右部最简化，左部无多余属性，无多余函数依赖</p><p>计算最小函数依赖集:具体流程对照上面最小函数依赖集的特征</p><h3 id="关系模式的分解"><a href="#关系模式的分解" class="headerlink" title="关系模式的分解:"></a>关系模式的分解:</h3><p>主要是要保证两个特性:无损连接性和依赖保持性</p><h4 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性:"></a>无损连接性:</h4><p>定义:原关系模式的每一个元组等于其在各个分解的关系模式的投影的自然连接</p><h5 id="检验算法1-图表法"><a href="#检验算法1-图表法" class="headerlink" title="检验算法1:图表法"></a>检验算法1:图表法</h5> <img src="https://i.loli.net/2021/06/13/qsZvnd2bmwckBGz.png" alt="image-20210611153320878" style="zoom:50%;" /> <img src="https://i.loli.net/2021/06/13/lNmAvIE5xn3wqjP.png" alt="image-20210611153335178" style="zoom:50%;" /><h5 id="检验算法2-二项分解定理"><a href="#检验算法2-二项分解定理" class="headerlink" title="检验算法2:二项分解定理"></a>检验算法2:二项分解定理</h5> <img src="https://i.loli.net/2021/06/13/2Rmb6cxfCykOPWp.png" alt="image-20210611153827672" style="zoom:50%;" /><h4 id="函数依赖保持性"><a href="#函数依赖保持性" class="headerlink" title="函数依赖保持性:"></a>函数依赖保持性:</h4><p>函数依赖集在属性子集上的投影概念:</p> <img src="https://i.loli.net/2021/06/13/pPiGBstXwo1vN76.png" alt="image-20210611154009254" style="zoom:50%;" /><p>函数依赖保持性的具体判定</p> <img src="https://i.loli.net/2021/06/13/g4BZiW1xPFpaq5H.png" alt="image-20210611154222833" style="zoom:50%;" /><h3 id="具体的关系模式分解算法"><a href="#具体的关系模式分解算法" class="headerlink" title="具体的关系模式分解算法"></a>具体的关系模式分解算法</h3><p>公理:任一关系模式，可以找到一个分解达到3NF,且具有无损连接性和函数依赖保持性。但是对于BCNF和4NF的模式分解的话，可以保证前者，但是无法保证后者。</p><p>两个算法:分解为3NF和BCNF</p><p>3NF目标算法:</p> <img src="https://i.loli.net/2021/06/13/RGnDIurVzgfKeMa.png" alt="image-20210611155338822" style="zoom:50%;" /><p>BCNF目标算法:</p><p>每一次分解之后各个模式的候选键要重新进行计算</p> <img src="https://i.loli.net/2021/06/13/kXcJe75WKgQZwBP.png" alt="image-20210611160034827" style="zoom:50%;" /><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>1.数据流图和数据字典(了解?)</p><p>2.自底向上概念结构设计的步骤:1.抽象数据并设计局部视图  2.逐步集成局部视图，得到全局概念结构</p><p>3.弱实体类型的一个特征是，仅使用该实体类型的属性无法唯一标识每个实体实例</p><p>合并ER图????????</p><p>ER图向关系模式的转换规则如下:</p> <img src="https://i.loli.net/2021/06/13/l4WZ6FpwDJHcQ8u.png" alt="image-20210611164828558" style="zoom:50%;" /> <img src="https://i.loli.net/2021/06/13/BP7vHxJLGF4Dh1M.png" alt="image-20210611164850823" style="zoom:50%;" /><h1 id="数据库保护与事务管理"><a href="#数据库保护与事务管理" class="headerlink" title="数据库保护与事务管理"></a>数据库保护与事务管理</h1><p>1.数据库系统安全模型的组成部分:身份认证，访问控制，视图限制，审计追踪和数据加密。</p><p>2.访问控制的分类:自主访问控制，强制访问控制，基于角色访问控制</p><p>3.自主访问控制在sql中的实现:(主要是权限的管理相关内容:grant, revoke关键字)</p><ul><li><p>表或视图权限的授予:</p><p>​<img src="https://i.loli.net/2021/06/13/TJ1vDH9gdNC82Sk.png" alt="image-20210612201500097" style="zoom: 50%;" /></p><p>with grant option意思是被授权的用户可以把授予他的特权继续授予其他用户</p></li><li><p>表或视图权限的回收:</p>  <img src="https://i.loli.net/2021/06/13/qTa9NyJEGf5LlVS.png" alt="image-20210612201608093" style="zoom:50%;" /></li><li><p>数据库角色的授权</p><p>创建角色(create role)</p><p>给角色进行授权</p><p>再把角色授权给其他角色</p></li></ul><p>剩下的要注意的就是完整性约束的相关内容:</p><p>​主键，外键，域，断言，触发器</p><p>​ 触发器的定义这一模块感觉要问一下老师具体的规范是什么样的</p><p>事务管理</p><p>事务的几个性质:</p><ul><li>原子性: 要么全部成功完成，要么全部都不完成</li><li>一致性: 数据库的每一个更新操作都必须遵循一定的完整性约束</li><li>隔离性: 多个事务内部做了什么事情是不可见的</li><li>持久性: 事务完成之后执行的结果永久在数据库中，永远有效</li></ul><p>数据库的恢复技术</p><p>1.基本单位:事务</p><p>2.可恢复性的基本原理:数据冗余</p><p>数据恢复的具体方法:</p><ul><li><p>数据转储</p><p>定期将整个数据库进行复制和备份</p><p>分为静态存储和动态存储，海量存储和增量存储</p><p>区别就是转储过程和用户事务是否可以并发执行</p><p>后面的分类就是字面意思</p></li><li><p>登记日志文件</p><p>日志文件:记录事务对数据库的更新操作的文件</p><p>以记录为单位，或者以数据块为单位</p><p>登记日志文件的原则:</p><p>​登记的次序严格按照并发事务执行的时间顺序</p><p>​必须先写日志文件，后写数据库，”日记先写原则”</p><p>​</p></li><li><p>检查点恢复技术</p><p>检查点:事务正常执行时，数据库系统按照一定的时间间隔设置检查点，恢复可以恢复到检查点上</p><p>专门在日志中加入检查点记录并定义相关的动作</p></li><li><p>数据库镜像</p></li><li><p>远程备份系统</p></li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>事务并发执行的几种可能错误</p><ul><li><p>丢失修改</p><p>两个事务同时对同一数据进行修改，其中一个事务的提交结果破坏了另一个事务的提交结果，造成修改的丢失</p></li><li><p>不可重复读</p><p>一个事务读取数据后，另一个事务执行更新操作，使前一个事务再次读出的数据和前面不一致</p><p>根据更新操作可以分为三种情况: 修改，删除，和插入</p></li><li><p>脏读</p><p>事务T1修改数据，并写回磁盘，事务T2读取了数据之后，T1又由于某种原因被撤销了，此时数据恢复原值，但是T2读取到的数据同数据库中的数据不一致</p></li></ul><p>锁机制</p><p>​排他锁(X锁):只允许拥有锁的事务进行读取和修改</p><p>​共享锁(S锁):只允许加锁事务修改</p><p>​死锁的诊断和解除:</p><p>​诊断:超时法和等待图法</p><p>​解除:一次封锁法和顺序封锁法</p><p>并发事务执行的可串行化</p><p>​可串行化调度的定义: 多个事务的并发执行是正确的当且仅当其结果与按某一次序串行地执行它们时地结果相同，就称这种调度策略时是可串行化的调度</p><p>两端锁协议</p> <img src="https://i.loli.net/2021/06/13/fQRPOIhEZ5Ylt6N.png" alt="image-20210613135521581" style="zoom: 67%;" /><p>封锁的粒度</p><p>​粒度越小，并发度就越高</p><p>​</p><p>多粒度锁</p><p>意向锁:如果想对一个节点加锁，就要先向其父节点加意向锁</p><p>分为IS,IX,SIX，IS—对子节点想加S锁，IX——对子节点想加X锁，SIX—-对它先加S锁再加IX锁</p><h1 id="注意的事项"><a href="#注意的事项" class="headerlink" title="注意的事项:"></a>注意的事项:</h1><p>分解3NF的时候针对的是Fm, 如果存在X-&gt;A，且XA&#x3D;U则直接是3NF</p><p>分解BCNF的时候针对的是F+!!!!</p><p>求解Fm的时候判断等价性的时候一定要把当前函数依赖去掉再求闭包</p><p>1NF—&gt;2NF:  直接将各个部分函数依赖合起来就行</p><p>1NF的形成条件: 不存在组合属性，不存在内部结构</p><p>R1R2那个二项分解定理是用来检验无损连接性的，检验函数依赖性的方法就那一个</p><p>就是检查F在各个属性集上的投影(算F+里的)并起来是否等于原值</p><p>select语句where子句允许多个AND和多个OR连接</p><p>create trigger grade_tirgger before update on s_c referencing new as x, old as y</p><p>注意这里new和old的as</p><p>书上的grant语句和(ppt上的和mysql中)有出入</p><h1 id="做题时发现要注意的知识点"><a href="#做题时发现要注意的知识点" class="headerlink" title="做题时发现要注意的知识点"></a>做题时发现要注意的知识点</h1><p>1.合并E-R图中的三个冲突的具体含义:</p><p>​属性冲突:  属性域冲突(属性值的类型取值范围或取值集合不同)或者是属性取值单位冲突</p><p>​命名冲突:  (结构是一样的，要是关系都是关系)同名异义(不同意义的对象在不同的局部ER图中具有相同的名字)或者是异名同义(同一意义的对象在不同ER图中有不同的名字)</p><p>​    结构冲突:  同一对象有不同的抽象: eg: 在一个图中当实体,另一个图中当属性</p><p>​   同一实体在不同图中属性的个数和次序不同</p><p>​   实体间的联系在不同的图中不完全相同</p><ol start="2"><li><p>判断3NF中提到了<strong>主属性和非主属性合起来决定非主属性的情况也叫非主属性之间的函数依赖</strong>。</p></li><li><p>数据独立性:  数据与程序间的互不依赖性</p><p>物理独立性:  数据库物理结构的改变不影响逻辑结构及应用程序</p><p>逻辑独立性:数据库逻辑结构的改变不影响应用程序</p><p>数据结构包含逻辑结构和物理结构</p></li><li><p>除法操作</p></li><li><p><strong>group by的一个问题</strong></p><p>之前一直以为select语句中如果有group by那么查询的字段只能是group by后面的字段以及狙聚集函数</p><p><strong>但是实验发现不是这样的!!</strong> 如果分组过后的组内的其他属性的值相同的话，也可以查询，例如</p><p>分组之后有这样的:(按日期分组)</p><table><thead><tr><th>Num</th><th>Date</th></tr></thead><tbody><tr><td>a1</td><td>t1</td></tr><tr><td>a1</td><td>t1</td></tr><tr><td>a1</td><td>t1</td></tr></tbody></table><p>那么select Num, Date from T group by Date</p><p>或者select Numfrom T group by Date都可以</p><p>还是看能否将这一字段的元组按照指定的属性进行分类!!!!</p></li><li><p>概念结构:ER图 ，逻辑结构:关系模型</p></li><li><p>事务控制管理分为两部分:恢复和并发控制</p></li><li><p>数据库系统安全技术:身份认证，访问控制，视图限制，审计追踪和数据加密。</p></li></ol><p>   数据库恢复技术:数据转储，登记日志文件，检查点恢复，数据库镜像，远程备份</p><ol start="11"><li><p>关系代数中的基本运算是并，差，投影，选择和笛卡尔积</p><p>连接可以转换为在笛卡尔积上的选择操作，除运算可以转换为选择和连接</p></li><li><p>可通过视图进行各种数据查询和更新操作(x)，书上说视图的特点之一就是更新有限制</p><p>并且有些视图是无法进行更新的!!-  p86比如把列平均值拿出来当做视图的属性</p></li><li><p>ALL(直接填入列名)是合法的嘛</p></li><li><p>数据库的三级模式体系有利于保持数据库的数据独立性</p></li><li><p>父类子类继承那一部分内容要重点看吗???</p></li><li><p>一个表中只有一个聚簇索引</p></li><li><p>(数据库访问技术)嵌入式sql, 4NF，查询的优化</p></li><li><p><strong>若关系模式R中全部是主属性，则R的最高范式必定是3NF，不可能是BCNF!!!!!</strong></p><p>3NF的不彻底性就表现在于主属性对候选键的部分函数依赖或者是传递函数依赖(会有插入和删除异常)</p><p>而BCNF的定义如下:</p><p><img src="https://i.loli.net/2021/06/15/LyMVKoixDkQY7cq.png" alt="image-20210615093313305"></p><p>这里强调Y不包含于X!!!!, 如果都是主属性的话必然不满足此条件</p><p><strong>类似的，如果R的候选码是一个全码，则R必定是BCNF</strong></p></li><li><p>事务的隔离性是由DBMS的并发控制子系统来实现的</p></li><li><img src="https://i.loli.net/2021/06/15/4YCUOA7caJgMvXd.png" alt="image-20210615094730787" style="zoom:50%;" /><p> 规则可以这样总结:  </p><pre><code>     S:  S,IS _</code></pre><p>​  X:  _</p><p>​  IS:   S,IS,IX,SIX,_</p><p>​  IX:  IX,IS,_</p><p>​  SIX: IS,_</p><p>​</p></li></ol><p></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/29/key-point/"/>
      <url>/2024/03/29/key-point/</url>
      
        <content type="html"><![CDATA[<h1 id="第3章要点"><a href="#第3章要点" class="headerlink" title="第3章要点"></a>第3章要点</h1><h3 id="1-从-NFA、DFA-到正则表达式的转换"><a href="#1-从-NFA、DFA-到正则表达式的转换" class="headerlink" title="1. 从 NFA、DFA 到正则表达式的转换"></a>1. 从 NFA、DFA 到正则表达式的转换</h3><p><a href="http://courses.engr.illinois.edu/cs373/sp2009/lectures/lect_08.pdf">http://courses.engr.illinois.edu/cs373/sp2009/lectures/lect_08.pdf</a></p><h3 id="2-KMP-及其扩展算法-p87"><a href="#2-KMP-及其扩展算法-p87" class="headerlink" title="2. KMP 及其扩展算法(p87)"></a>2. KMP 及其扩展算法(p87)</h3><p>参考 matrix 的博文 <a href="http://www.matrix67.com/blog/archives/115">KMP算法详解</a>。文中提供了例子，比较容易理解。</p><h3 id="3-字符串处理算法的效率-p103"><a href="#3-字符串处理算法的效率-p103" class="headerlink" title="3. 字符串处理算法的效率(p103)"></a>3. 字符串处理算法的效率(p103)</h3><p>对于每个构造得到的 DFA 状态，我们最多必须构造 4|r| 个新状态</p><h3 id="4-DFA-模拟中的时间和空间的权衡-p116"><a href="#4-DFA-模拟中的时间和空间的权衡-p116" class="headerlink" title="4. DFA 模拟中的时间和空间的权衡(p116)"></a>4. DFA 模拟中的时间和空间的权衡(p116)</h3><p>图 3-66 表示的算法</p><h3 id="5-最小化一个-DFA-的状态数量（p115）"><a href="#5-最小化一个-DFA-的状态数量（p115）" class="headerlink" title="5. 最小化一个 DFA 的状态数量（p115）"></a>5. 最小化一个 DFA 的状态数量（p115）</h3><p>注意图 3-64 的第 4 行：“状态 s 和 t 在 a 上的转换都到达 Π 中的同一组”，而不是到达同一个状态。如果通过是否到达同一个状态来判定，那么如果 s 和 t 在 a 上的转换到了两个不同但不能区分的状态时，就会认为 s 和 t 是可区分的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/29/mysql/"/>
      <url>/2024/03/29/mysql/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/geaozhang/p/6710454.html">MySQL用户认证及权限控制 - GeaoZhang - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_45173404/article/details/115712758">(23条消息) MySQL详细学习教程（建议收藏）_Baret-H的博客-CSDN博客_mysql教程</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/23/%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
      <url>/2024/03/23/%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/%E6%90%AD%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/17/README/"/>
      <url>/2024/03/17/README/</url>
      
        <content type="html"><![CDATA[<h1 id="LLM-Attacks"><a href="#LLM-Attacks" class="headerlink" title="LLM Attacks"></a>LLM Attacks</h1><p><a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT"></a></p><p>This is the official repository for “<a href="https://arxiv.org/abs/2307.15043">Universal and Transferable Adversarial Attacks on Aligned Language Models</a>“ by <a href="https://andyzoujm.github.io/">Andy Zou</a>, <a href="https://sites.google.com/west.cmu.edu/zifan-wang/home">Zifan Wang</a>, <a href="https://zicokolter.com/">J. Zico Kolter</a>, and <a href="https://www.cs.cmu.edu/~mfredrik/">Matt Fredrikson</a>.</p><p>Check out our <a href="https://llm-attacks.org/">website and demo here</a>.</p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><ul><li>(2023-08-16) We include a notebook <code>demo.ipynb</code> (or see it on <a href="https://colab.research.google.com/drive/1dinZSyP1E4KokSLPcCh1JQFUFsN-WV--?usp=sharing">Colab</a>) containing the minimal implementation of GCG for jailbreaking LLaMA-2 for generating harmful completion.</li></ul><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><a href="#installation">Installation</a></li><li><a href="#models">Models</a></li><li><a href="#experiments">Experiments</a></li><li><a href="#demo">Demo</a></li><li><a href="#reproducibility">Reproducibility</a></li><li><a href="#license">License</a></li><li><a href="#citation">Citation</a></li></ul><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>We need the newest version of FastChat <code>fschat==0.2.23</code> and please make sure to install this version. The <code>llm-attacks</code> package can be installed by running the following command at the root of this repository:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Please follow the instructions to download Vicuna-7B or&#x2F;and LLaMA-2-7B-Chat first (we use the weights converted by HuggingFace <a href="https://huggingface.co/meta-llama/Llama-2-7b-hf">here</a>).  Our script by default assumes models are stored in a root directory named as <code>/DIR</code>. To modify the paths to your models and tokenizers, please add the following lines in <code>experiments/configs/individual_xxx.py</code> (for individual experiment) and <code>experiments/configs/transfer_xxx.py</code> (for multiple behaviors or transfer experiment). An example is given as follows.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config.model_paths = [</span><br><span class="line">    <span class="string">&quot;/DIR/vicuna/vicuna-7b-v1.3&quot;</span>,</span><br><span class="line">    ... <span class="comment"># more models</span></span><br><span class="line">]</span><br><span class="line">config.tokenizer_paths = [</span><br><span class="line">    <span class="string">&quot;/DIR/vicuna/vicuna-7b-v1.3&quot;</span>,</span><br><span class="line">    ... <span class="comment"># more tokenizers</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>We include a notebook <code>demo.ipynb</code> which provides an example on attacking LLaMA-2 with GCG. You can also view this notebook on <a href="https://colab.research.google.com/drive/1dinZSyP1E4KokSLPcCh1JQFUFsN-WV--?usp=sharing">Colab</a>. This notebook uses a minimal implementation of GCG so it should be only used to get familiar with the attack algorithm. For running experiments with more behaviors, please check Section Experiments. To monitor the loss in the demo we use <code>livelossplot</code>, so one should install this library first by pip.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install livelossplot</span><br></pre></td></tr></table></figure><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>The <code>experiments</code> folder contains code to reproduce GCG experiments on AdvBench.</p><ul><li>To run individual experiments with harmful behaviors and harmful strings (i.e. 1 behavior, 1 model or 1 string, 1 model), run the following code inside <code>experiments</code> (changing <code>vicuna</code> to <code>llama2</code> and changing <code>behaviors</code> to <code>strings</code> will switch to different experiment setups):</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> launch_scripts</span><br><span class="line">bash run_gcg_individual.sh vicuna behaviors</span><br></pre></td></tr></table></figure><ul><li>To perform multiple behaviors experiments (i.e. 25 behaviors, 1 model), run the following code inside <code>experiments</code>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> launch_scripts</span><br><span class="line">bash run_gcg_multiple.sh vicuna <span class="comment"># or llama2</span></span><br></pre></td></tr></table></figure><ul><li>To perform transfer experiments (i.e. 25 behaviors, 2 models), run the following code inside <code>experiments</code>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> launch_scripts</span><br><span class="line">bash run_gcg_transfer.sh vicuna 2 <span class="comment"># or vicuna_guanaco 4</span></span><br></pre></td></tr></table></figure><ul><li>To perform evaluation experiments, please follow the directions in <code>experiments/parse_results.ipynb</code>.</li></ul><p>Notice that all hyper-parameters in our experiments are handled by the <code>ml_collections</code> package <a href="https://github.com/google/ml_collections">here</a>. You can directly change those hyper-parameters at the place they are defined, e.g. <code>experiments/configs/individual_xxx.py</code>. However, a recommended way of passing different hyper-parameters – for instance you would like to try another model – is to do it in the launch script. Check out our launch scripts in <code>experiments/launch_scripts</code> for examples. For more information about <code>ml_collections</code>, please refer to their <a href="https://github.com/google/ml_collections">repository</a>.</p><h2 id="Reproducibility"><a href="#Reproducibility" class="headerlink" title="Reproducibility"></a>Reproducibility</h2><p>A note for hardware: all experiments we run use one or multiple NVIDIA A100 GPUs, which have 80G memory per chip. </p><p>We include a few examples people told us when reproducing our results. They might also include workaround for solving a similar issue in your situation. </p><ul><li><a href="https://github.com/llm-attacks/llm-attacks/issues/8">Prompting Llama-2-7B-Chat-GGML</a></li><li><a href="https://github.com/llm-attacks/llm-attacks/issues/28">Possible Naming Issue for Running Experiments on Windows</a></li></ul><p>Currently the codebase only supports training with LLaMA or Pythia based models. Running the scripts with other models (with different tokenizers) will likely result in silent errors. As a tip, start by modifying <a href="https://github.com/llm-attacks/llm-attacks/blob/main/llm_attacks/base/attack_manager.py#L130">this function</a> where different slices are defined for the model.</p><h2 id="Citation"><a href="#Citation" class="headerlink" title="Citation"></a>Citation</h2><p>If you find this useful in your research, please consider citing:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@misc&#123;zou2023universal,</span><br><span class="line">      title=&#123;Universal and Transferable Adversarial Attacks on Aligned Language Models&#125;, </span><br><span class="line">      author=&#123;Andy Zou and Zifan Wang and J. Zico Kolter and Matt Fredrikson&#125;,</span><br><span class="line">      year=&#123;2023&#125;,</span><br><span class="line">      eprint=&#123;2307.15043&#125;,</span><br><span class="line">      archivePrefix=&#123;arXiv&#125;,</span><br><span class="line">      primaryClass=&#123;cs.CL&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><code>llm-attacks</code> is licensed under the terms of the MIT license. See LICENSE for more details.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2024/01/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/01/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>建一个博客玩玩！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/17/hello-world/"/>
      <url>/2024/01/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
